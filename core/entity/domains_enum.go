// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package entity

import (
	"fmt"
	"strings"
)

const (
	// AlarmControlPanelStateDisarmed is a AlarmControlPanelState of type Disarmed.
	AlarmControlPanelStateDisarmed AlarmControlPanelState = iota
	// AlarmControlPanelStateArmedHome is a AlarmControlPanelState of type Armed_home.
	AlarmControlPanelStateArmedHome
	// AlarmControlPanelStateArmedAway is a AlarmControlPanelState of type Armed_away.
	AlarmControlPanelStateArmedAway
	// AlarmControlPanelStateArmedNight is a AlarmControlPanelState of type Armed_night.
	AlarmControlPanelStateArmedNight
	// AlarmControlPanelStateArmedVacation is a AlarmControlPanelState of type Armed_vacation.
	AlarmControlPanelStateArmedVacation
	// AlarmControlPanelStateArmedCustomBypass is a AlarmControlPanelState of type Armed_custom_bypass.
	AlarmControlPanelStateArmedCustomBypass
	// AlarmControlPanelStatePending is a AlarmControlPanelState of type Pending.
	AlarmControlPanelStatePending
	// AlarmControlPanelStateArming is a AlarmControlPanelState of type Arming.
	AlarmControlPanelStateArming
	// AlarmControlPanelStateDisarming is a AlarmControlPanelState of type Disarming.
	AlarmControlPanelStateDisarming
	// AlarmControlPanelStateTriggered is a AlarmControlPanelState of type Triggered.
	AlarmControlPanelStateTriggered
)

var ErrInvalidAlarmControlPanelState = fmt.Errorf("not a valid AlarmControlPanelState, try [%s]", strings.Join(_AlarmControlPanelStateNames, ", "))

const _AlarmControlPanelStateName = "disarmedarmed_homearmed_awayarmed_nightarmed_vacationarmed_custom_bypasspendingarmingdisarmingtriggered"

var _AlarmControlPanelStateNames = []string{
	_AlarmControlPanelStateName[0:8],
	_AlarmControlPanelStateName[8:18],
	_AlarmControlPanelStateName[18:28],
	_AlarmControlPanelStateName[28:39],
	_AlarmControlPanelStateName[39:53],
	_AlarmControlPanelStateName[53:72],
	_AlarmControlPanelStateName[72:79],
	_AlarmControlPanelStateName[79:85],
	_AlarmControlPanelStateName[85:94],
	_AlarmControlPanelStateName[94:103],
}

// AlarmControlPanelStateNames returns a list of possible string values of AlarmControlPanelState.
func AlarmControlPanelStateNames() []string {
	tmp := make([]string, len(_AlarmControlPanelStateNames))
	copy(tmp, _AlarmControlPanelStateNames)
	return tmp
}

// AlarmControlPanelStateValues returns a list of the values for AlarmControlPanelState
func AlarmControlPanelStateValues() []AlarmControlPanelState {
	return []AlarmControlPanelState{
		AlarmControlPanelStateDisarmed,
		AlarmControlPanelStateArmedHome,
		AlarmControlPanelStateArmedAway,
		AlarmControlPanelStateArmedNight,
		AlarmControlPanelStateArmedVacation,
		AlarmControlPanelStateArmedCustomBypass,
		AlarmControlPanelStatePending,
		AlarmControlPanelStateArming,
		AlarmControlPanelStateDisarming,
		AlarmControlPanelStateTriggered,
	}
}

var _AlarmControlPanelStateMap = map[AlarmControlPanelState]string{
	AlarmControlPanelStateDisarmed:          _AlarmControlPanelStateName[0:8],
	AlarmControlPanelStateArmedHome:         _AlarmControlPanelStateName[8:18],
	AlarmControlPanelStateArmedAway:         _AlarmControlPanelStateName[18:28],
	AlarmControlPanelStateArmedNight:        _AlarmControlPanelStateName[28:39],
	AlarmControlPanelStateArmedVacation:     _AlarmControlPanelStateName[39:53],
	AlarmControlPanelStateArmedCustomBypass: _AlarmControlPanelStateName[53:72],
	AlarmControlPanelStatePending:           _AlarmControlPanelStateName[72:79],
	AlarmControlPanelStateArming:            _AlarmControlPanelStateName[79:85],
	AlarmControlPanelStateDisarming:         _AlarmControlPanelStateName[85:94],
	AlarmControlPanelStateTriggered:         _AlarmControlPanelStateName[94:103],
}

// String implements the Stringer interface.
func (x AlarmControlPanelState) String() string {
	if str, ok := _AlarmControlPanelStateMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AlarmControlPanelState(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AlarmControlPanelState) IsValid() bool {
	_, ok := _AlarmControlPanelStateMap[x]
	return ok
}

var _AlarmControlPanelStateValue = map[string]AlarmControlPanelState{
	_AlarmControlPanelStateName[0:8]:    AlarmControlPanelStateDisarmed,
	_AlarmControlPanelStateName[8:18]:   AlarmControlPanelStateArmedHome,
	_AlarmControlPanelStateName[18:28]:  AlarmControlPanelStateArmedAway,
	_AlarmControlPanelStateName[28:39]:  AlarmControlPanelStateArmedNight,
	_AlarmControlPanelStateName[39:53]:  AlarmControlPanelStateArmedVacation,
	_AlarmControlPanelStateName[53:72]:  AlarmControlPanelStateArmedCustomBypass,
	_AlarmControlPanelStateName[72:79]:  AlarmControlPanelStatePending,
	_AlarmControlPanelStateName[79:85]:  AlarmControlPanelStateArming,
	_AlarmControlPanelStateName[85:94]:  AlarmControlPanelStateDisarming,
	_AlarmControlPanelStateName[94:103]: AlarmControlPanelStateTriggered,
}

// ParseAlarmControlPanelState attempts to convert a string to a AlarmControlPanelState.
func ParseAlarmControlPanelState(name string) (AlarmControlPanelState, error) {
	if x, ok := _AlarmControlPanelStateValue[name]; ok {
		return x, nil
	}
	return AlarmControlPanelState(0), fmt.Errorf("%s is %w", name, ErrInvalidAlarmControlPanelState)
}

// MarshalText implements the text marshaller method.
func (x AlarmControlPanelState) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AlarmControlPanelState) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAlarmControlPanelState(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// BinarySensorDeviceClassBattery is a BinarySensorDeviceClass of type battery.
	BinarySensorDeviceClassBattery BinarySensorDeviceClass = "battery"
	// BinarySensorDeviceClassBatteryCharging is a BinarySensorDeviceClass of type battery_charging.
	BinarySensorDeviceClassBatteryCharging BinarySensorDeviceClass = "battery_charging"
	// BinarySensorDeviceClassCarbonMonoxide is a BinarySensorDeviceClass of type carbon_monoxide.
	BinarySensorDeviceClassCarbonMonoxide BinarySensorDeviceClass = "carbon_monoxide"
	// BinarySensorDeviceClassCold is a BinarySensorDeviceClass of type cold.
	BinarySensorDeviceClassCold BinarySensorDeviceClass = "cold"
	// BinarySensorDeviceClassConnectivity is a BinarySensorDeviceClass of type connectivity.
	BinarySensorDeviceClassConnectivity BinarySensorDeviceClass = "connectivity"
	// BinarySensorDeviceClassDoor is a BinarySensorDeviceClass of type door.
	BinarySensorDeviceClassDoor BinarySensorDeviceClass = "door"
	// BinarySensorDeviceClassEmpty is a BinarySensorDeviceClass of type empty.
	BinarySensorDeviceClassEmpty BinarySensorDeviceClass = "empty"
	// BinarySensorDeviceClassGarageDoor is a BinarySensorDeviceClass of type garage_door.
	BinarySensorDeviceClassGarageDoor BinarySensorDeviceClass = "garage_door"
	// BinarySensorDeviceClassGas is a BinarySensorDeviceClass of type gas.
	BinarySensorDeviceClassGas BinarySensorDeviceClass = "gas"
	// BinarySensorDeviceClassHeat is a BinarySensorDeviceClass of type heat.
	BinarySensorDeviceClassHeat BinarySensorDeviceClass = "heat"
	// BinarySensorDeviceClassLight is a BinarySensorDeviceClass of type light.
	BinarySensorDeviceClassLight BinarySensorDeviceClass = "light"
	// BinarySensorDeviceClassLock is a BinarySensorDeviceClass of type lock.
	BinarySensorDeviceClassLock BinarySensorDeviceClass = "lock"
	// BinarySensorDeviceClassMoisture is a BinarySensorDeviceClass of type moisture.
	BinarySensorDeviceClassMoisture BinarySensorDeviceClass = "moisture"
	// BinarySensorDeviceClassMotion is a BinarySensorDeviceClass of type motion.
	BinarySensorDeviceClassMotion BinarySensorDeviceClass = "motion"
	// BinarySensorDeviceClassMoving is a BinarySensorDeviceClass of type moving.
	BinarySensorDeviceClassMoving BinarySensorDeviceClass = "moving"
	// BinarySensorDeviceClassOccupancy is a BinarySensorDeviceClass of type occupancy.
	BinarySensorDeviceClassOccupancy BinarySensorDeviceClass = "occupancy"
	// BinarySensorDeviceClassOpening is a BinarySensorDeviceClass of type opening.
	BinarySensorDeviceClassOpening BinarySensorDeviceClass = "opening"
	// BinarySensorDeviceClassPlug is a BinarySensorDeviceClass of type plug.
	BinarySensorDeviceClassPlug BinarySensorDeviceClass = "plug"
	// BinarySensorDeviceClassPower is a BinarySensorDeviceClass of type power.
	BinarySensorDeviceClassPower BinarySensorDeviceClass = "power"
	// BinarySensorDeviceClassPresence is a BinarySensorDeviceClass of type presence.
	BinarySensorDeviceClassPresence BinarySensorDeviceClass = "presence"
	// BinarySensorDeviceClassProblem is a BinarySensorDeviceClass of type problem.
	BinarySensorDeviceClassProblem BinarySensorDeviceClass = "problem"
	// BinarySensorDeviceClassRunning is a BinarySensorDeviceClass of type running.
	BinarySensorDeviceClassRunning BinarySensorDeviceClass = "running"
	// BinarySensorDeviceClassSafety is a BinarySensorDeviceClass of type safety.
	BinarySensorDeviceClassSafety BinarySensorDeviceClass = "safety"
	// BinarySensorDeviceClassSmoke is a BinarySensorDeviceClass of type smoke.
	BinarySensorDeviceClassSmoke BinarySensorDeviceClass = "smoke"
	// BinarySensorDeviceClassSound is a BinarySensorDeviceClass of type sound.
	BinarySensorDeviceClassSound BinarySensorDeviceClass = "sound"
	// BinarySensorDeviceClassTamper is a BinarySensorDeviceClass of type tamper.
	BinarySensorDeviceClassTamper BinarySensorDeviceClass = "tamper"
	// BinarySensorDeviceClassUpdate is a BinarySensorDeviceClass of type update.
	BinarySensorDeviceClassUpdate BinarySensorDeviceClass = "update"
	// BinarySensorDeviceClassVibration is a BinarySensorDeviceClass of type vibration.
	BinarySensorDeviceClassVibration BinarySensorDeviceClass = "vibration"
	// BinarySensorDeviceClassWindow is a BinarySensorDeviceClass of type window.
	BinarySensorDeviceClassWindow BinarySensorDeviceClass = "window"
)

var ErrInvalidBinarySensorDeviceClass = fmt.Errorf("not a valid BinarySensorDeviceClass, try [%s]", strings.Join(_BinarySensorDeviceClassNames, ", "))

var _BinarySensorDeviceClassNames = []string{
	string(BinarySensorDeviceClassBattery),
	string(BinarySensorDeviceClassBatteryCharging),
	string(BinarySensorDeviceClassCarbonMonoxide),
	string(BinarySensorDeviceClassCold),
	string(BinarySensorDeviceClassConnectivity),
	string(BinarySensorDeviceClassDoor),
	string(BinarySensorDeviceClassEmpty),
	string(BinarySensorDeviceClassGarageDoor),
	string(BinarySensorDeviceClassGas),
	string(BinarySensorDeviceClassHeat),
	string(BinarySensorDeviceClassLight),
	string(BinarySensorDeviceClassLock),
	string(BinarySensorDeviceClassMoisture),
	string(BinarySensorDeviceClassMotion),
	string(BinarySensorDeviceClassMoving),
	string(BinarySensorDeviceClassOccupancy),
	string(BinarySensorDeviceClassOpening),
	string(BinarySensorDeviceClassPlug),
	string(BinarySensorDeviceClassPower),
	string(BinarySensorDeviceClassPresence),
	string(BinarySensorDeviceClassProblem),
	string(BinarySensorDeviceClassRunning),
	string(BinarySensorDeviceClassSafety),
	string(BinarySensorDeviceClassSmoke),
	string(BinarySensorDeviceClassSound),
	string(BinarySensorDeviceClassTamper),
	string(BinarySensorDeviceClassUpdate),
	string(BinarySensorDeviceClassVibration),
	string(BinarySensorDeviceClassWindow),
}

// BinarySensorDeviceClassNames returns a list of possible string values of BinarySensorDeviceClass.
func BinarySensorDeviceClassNames() []string {
	tmp := make([]string, len(_BinarySensorDeviceClassNames))
	copy(tmp, _BinarySensorDeviceClassNames)
	return tmp
}

// BinarySensorDeviceClassValues returns a list of the values for BinarySensorDeviceClass
func BinarySensorDeviceClassValues() []BinarySensorDeviceClass {
	return []BinarySensorDeviceClass{
		BinarySensorDeviceClassBattery,
		BinarySensorDeviceClassBatteryCharging,
		BinarySensorDeviceClassCarbonMonoxide,
		BinarySensorDeviceClassCold,
		BinarySensorDeviceClassConnectivity,
		BinarySensorDeviceClassDoor,
		BinarySensorDeviceClassEmpty,
		BinarySensorDeviceClassGarageDoor,
		BinarySensorDeviceClassGas,
		BinarySensorDeviceClassHeat,
		BinarySensorDeviceClassLight,
		BinarySensorDeviceClassLock,
		BinarySensorDeviceClassMoisture,
		BinarySensorDeviceClassMotion,
		BinarySensorDeviceClassMoving,
		BinarySensorDeviceClassOccupancy,
		BinarySensorDeviceClassOpening,
		BinarySensorDeviceClassPlug,
		BinarySensorDeviceClassPower,
		BinarySensorDeviceClassPresence,
		BinarySensorDeviceClassProblem,
		BinarySensorDeviceClassRunning,
		BinarySensorDeviceClassSafety,
		BinarySensorDeviceClassSmoke,
		BinarySensorDeviceClassSound,
		BinarySensorDeviceClassTamper,
		BinarySensorDeviceClassUpdate,
		BinarySensorDeviceClassVibration,
		BinarySensorDeviceClassWindow,
	}
}

// String implements the Stringer interface.
func (x BinarySensorDeviceClass) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BinarySensorDeviceClass) IsValid() bool {
	_, err := ParseBinarySensorDeviceClass(string(x))
	return err == nil
}

var _BinarySensorDeviceClassValue = map[string]BinarySensorDeviceClass{
	"battery":          BinarySensorDeviceClassBattery,
	"battery_charging": BinarySensorDeviceClassBatteryCharging,
	"carbon_monoxide":  BinarySensorDeviceClassCarbonMonoxide,
	"cold":             BinarySensorDeviceClassCold,
	"connectivity":     BinarySensorDeviceClassConnectivity,
	"door":             BinarySensorDeviceClassDoor,
	"empty":            BinarySensorDeviceClassEmpty,
	"garage_door":      BinarySensorDeviceClassGarageDoor,
	"gas":              BinarySensorDeviceClassGas,
	"heat":             BinarySensorDeviceClassHeat,
	"light":            BinarySensorDeviceClassLight,
	"lock":             BinarySensorDeviceClassLock,
	"moisture":         BinarySensorDeviceClassMoisture,
	"motion":           BinarySensorDeviceClassMotion,
	"moving":           BinarySensorDeviceClassMoving,
	"occupancy":        BinarySensorDeviceClassOccupancy,
	"opening":          BinarySensorDeviceClassOpening,
	"plug":             BinarySensorDeviceClassPlug,
	"power":            BinarySensorDeviceClassPower,
	"presence":         BinarySensorDeviceClassPresence,
	"problem":          BinarySensorDeviceClassProblem,
	"running":          BinarySensorDeviceClassRunning,
	"safety":           BinarySensorDeviceClassSafety,
	"smoke":            BinarySensorDeviceClassSmoke,
	"sound":            BinarySensorDeviceClassSound,
	"tamper":           BinarySensorDeviceClassTamper,
	"update":           BinarySensorDeviceClassUpdate,
	"vibration":        BinarySensorDeviceClassVibration,
	"window":           BinarySensorDeviceClassWindow,
}

// ParseBinarySensorDeviceClass attempts to convert a string to a BinarySensorDeviceClass.
func ParseBinarySensorDeviceClass(name string) (BinarySensorDeviceClass, error) {
	if x, ok := _BinarySensorDeviceClassValue[name]; ok {
		return x, nil
	}
	return BinarySensorDeviceClass(""), fmt.Errorf("%s is %w", name, ErrInvalidBinarySensorDeviceClass)
}

// MarshalText implements the text marshaller method.
func (x BinarySensorDeviceClass) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BinarySensorDeviceClass) UnmarshalText(text []byte) error {
	tmp, err := ParseBinarySensorDeviceClass(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ButtonDeviceClassIdentify is a ButtonDeviceClass of type identify.
	// The button is used to identify a device.
	ButtonDeviceClassIdentify ButtonDeviceClass = "identify"
	// ButtonDeviceClassRestart is a ButtonDeviceClass of type restart.
	// The button restarts the device.
	ButtonDeviceClassRestart ButtonDeviceClass = "restart"
	// ButtonDeviceClassUpdate is a ButtonDeviceClass of type update.
	// The button updates the software of the device.
	ButtonDeviceClassUpdate ButtonDeviceClass = "update"
)

var ErrInvalidButtonDeviceClass = fmt.Errorf("not a valid ButtonDeviceClass, try [%s]", strings.Join(_ButtonDeviceClassNames, ", "))

var _ButtonDeviceClassNames = []string{
	string(ButtonDeviceClassIdentify),
	string(ButtonDeviceClassRestart),
	string(ButtonDeviceClassUpdate),
}

// ButtonDeviceClassNames returns a list of possible string values of ButtonDeviceClass.
func ButtonDeviceClassNames() []string {
	tmp := make([]string, len(_ButtonDeviceClassNames))
	copy(tmp, _ButtonDeviceClassNames)
	return tmp
}

// ButtonDeviceClassValues returns a list of the values for ButtonDeviceClass
func ButtonDeviceClassValues() []ButtonDeviceClass {
	return []ButtonDeviceClass{
		ButtonDeviceClassIdentify,
		ButtonDeviceClassRestart,
		ButtonDeviceClassUpdate,
	}
}

// String implements the Stringer interface.
func (x ButtonDeviceClass) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ButtonDeviceClass) IsValid() bool {
	_, err := ParseButtonDeviceClass(string(x))
	return err == nil
}

var _ButtonDeviceClassValue = map[string]ButtonDeviceClass{
	"identify": ButtonDeviceClassIdentify,
	"restart":  ButtonDeviceClassRestart,
	"update":   ButtonDeviceClassUpdate,
}

// ParseButtonDeviceClass attempts to convert a string to a ButtonDeviceClass.
func ParseButtonDeviceClass(name string) (ButtonDeviceClass, error) {
	if x, ok := _ButtonDeviceClassValue[name]; ok {
		return x, nil
	}
	return ButtonDeviceClass(""), fmt.Errorf("%s is %w", name, ErrInvalidButtonDeviceClass)
}

// MarshalText implements the text marshaller method.
func (x ButtonDeviceClass) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ButtonDeviceClass) UnmarshalText(text []byte) error {
	tmp, err := ParseButtonDeviceClass(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ClimateActionOff is a ClimateAction of type Off.
	ClimateActionOff ClimateAction = iota
	// ClimateActionCooling is a ClimateAction of type Cooling.
	ClimateActionCooling
	// ClimateActionHeating is a ClimateAction of type Heating.
	ClimateActionHeating
	// ClimateActionIdle is a ClimateAction of type Idle.
	ClimateActionIdle
	// ClimateActionDrying is a ClimateAction of type Drying.
	ClimateActionDrying
	// ClimateActionFan is a ClimateAction of type Fan.
	ClimateActionFan
)

var ErrInvalidClimateAction = fmt.Errorf("not a valid ClimateAction, try [%s]", strings.Join(_ClimateActionNames, ", "))

const _ClimateActionName = "offcoolingheatingidledryingfan"

var _ClimateActionNames = []string{
	_ClimateActionName[0:3],
	_ClimateActionName[3:10],
	_ClimateActionName[10:17],
	_ClimateActionName[17:21],
	_ClimateActionName[21:27],
	_ClimateActionName[27:30],
}

// ClimateActionNames returns a list of possible string values of ClimateAction.
func ClimateActionNames() []string {
	tmp := make([]string, len(_ClimateActionNames))
	copy(tmp, _ClimateActionNames)
	return tmp
}

// ClimateActionValues returns a list of the values for ClimateAction
func ClimateActionValues() []ClimateAction {
	return []ClimateAction{
		ClimateActionOff,
		ClimateActionCooling,
		ClimateActionHeating,
		ClimateActionIdle,
		ClimateActionDrying,
		ClimateActionFan,
	}
}

var _ClimateActionMap = map[ClimateAction]string{
	ClimateActionOff:     _ClimateActionName[0:3],
	ClimateActionCooling: _ClimateActionName[3:10],
	ClimateActionHeating: _ClimateActionName[10:17],
	ClimateActionIdle:    _ClimateActionName[17:21],
	ClimateActionDrying:  _ClimateActionName[21:27],
	ClimateActionFan:     _ClimateActionName[27:30],
}

// String implements the Stringer interface.
func (x ClimateAction) String() string {
	if str, ok := _ClimateActionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ClimateAction(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ClimateAction) IsValid() bool {
	_, ok := _ClimateActionMap[x]
	return ok
}

var _ClimateActionValue = map[string]ClimateAction{
	_ClimateActionName[0:3]:   ClimateActionOff,
	_ClimateActionName[3:10]:  ClimateActionCooling,
	_ClimateActionName[10:17]: ClimateActionHeating,
	_ClimateActionName[17:21]: ClimateActionIdle,
	_ClimateActionName[21:27]: ClimateActionDrying,
	_ClimateActionName[27:30]: ClimateActionFan,
}

// ParseClimateAction attempts to convert a string to a ClimateAction.
func ParseClimateAction(name string) (ClimateAction, error) {
	if x, ok := _ClimateActionValue[name]; ok {
		return x, nil
	}
	return ClimateAction(0), fmt.Errorf("%s is %w", name, ErrInvalidClimateAction)
}

// MarshalText implements the text marshaller method.
func (x ClimateAction) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ClimateAction) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseClimateAction(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ClimateFanModeOn is a ClimateFanMode of type On.
	ClimateFanModeOn ClimateFanMode = iota
	// ClimateFanModeOff is a ClimateFanMode of type Off.
	ClimateFanModeOff
	// ClimateFanModeAuto is a ClimateFanMode of type Auto.
	ClimateFanModeAuto
	// ClimateFanModeLow is a ClimateFanMode of type Low.
	ClimateFanModeLow
	// ClimateFanModeMedium is a ClimateFanMode of type Medium.
	ClimateFanModeMedium
	// ClimateFanModeHigh is a ClimateFanMode of type High.
	ClimateFanModeHigh
	// ClimateFanModeMiddle is a ClimateFanMode of type Middle.
	ClimateFanModeMiddle
	// ClimateFanModeFocus is a ClimateFanMode of type Focus.
	ClimateFanModeFocus
	// ClimateFanModeDiffuse is a ClimateFanMode of type Diffuse.
	ClimateFanModeDiffuse
	// ClimateFanModeQuiet is a ClimateFanMode of type Quiet.
	ClimateFanModeQuiet
)

var ErrInvalidClimateFanMode = fmt.Errorf("not a valid ClimateFanMode, try [%s]", strings.Join(_ClimateFanModeNames, ", "))

const _ClimateFanModeName = "onoffautolowmediumhighmiddlefocusdiffusequiet"

var _ClimateFanModeNames = []string{
	_ClimateFanModeName[0:2],
	_ClimateFanModeName[2:5],
	_ClimateFanModeName[5:9],
	_ClimateFanModeName[9:12],
	_ClimateFanModeName[12:18],
	_ClimateFanModeName[18:22],
	_ClimateFanModeName[22:28],
	_ClimateFanModeName[28:33],
	_ClimateFanModeName[33:40],
	_ClimateFanModeName[40:45],
}

// ClimateFanModeNames returns a list of possible string values of ClimateFanMode.
func ClimateFanModeNames() []string {
	tmp := make([]string, len(_ClimateFanModeNames))
	copy(tmp, _ClimateFanModeNames)
	return tmp
}

// ClimateFanModeValues returns a list of the values for ClimateFanMode
func ClimateFanModeValues() []ClimateFanMode {
	return []ClimateFanMode{
		ClimateFanModeOn,
		ClimateFanModeOff,
		ClimateFanModeAuto,
		ClimateFanModeLow,
		ClimateFanModeMedium,
		ClimateFanModeHigh,
		ClimateFanModeMiddle,
		ClimateFanModeFocus,
		ClimateFanModeDiffuse,
		ClimateFanModeQuiet,
	}
}

var _ClimateFanModeMap = map[ClimateFanMode]string{
	ClimateFanModeOn:      _ClimateFanModeName[0:2],
	ClimateFanModeOff:     _ClimateFanModeName[2:5],
	ClimateFanModeAuto:    _ClimateFanModeName[5:9],
	ClimateFanModeLow:     _ClimateFanModeName[9:12],
	ClimateFanModeMedium:  _ClimateFanModeName[12:18],
	ClimateFanModeHigh:    _ClimateFanModeName[18:22],
	ClimateFanModeMiddle:  _ClimateFanModeName[22:28],
	ClimateFanModeFocus:   _ClimateFanModeName[28:33],
	ClimateFanModeDiffuse: _ClimateFanModeName[33:40],
	ClimateFanModeQuiet:   _ClimateFanModeName[40:45],
}

// String implements the Stringer interface.
func (x ClimateFanMode) String() string {
	if str, ok := _ClimateFanModeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ClimateFanMode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ClimateFanMode) IsValid() bool {
	_, ok := _ClimateFanModeMap[x]
	return ok
}

var _ClimateFanModeValue = map[string]ClimateFanMode{
	_ClimateFanModeName[0:2]:   ClimateFanModeOn,
	_ClimateFanModeName[2:5]:   ClimateFanModeOff,
	_ClimateFanModeName[5:9]:   ClimateFanModeAuto,
	_ClimateFanModeName[9:12]:  ClimateFanModeLow,
	_ClimateFanModeName[12:18]: ClimateFanModeMedium,
	_ClimateFanModeName[18:22]: ClimateFanModeHigh,
	_ClimateFanModeName[22:28]: ClimateFanModeMiddle,
	_ClimateFanModeName[28:33]: ClimateFanModeFocus,
	_ClimateFanModeName[33:40]: ClimateFanModeDiffuse,
	_ClimateFanModeName[40:45]: ClimateFanModeQuiet,
}

// ParseClimateFanMode attempts to convert a string to a ClimateFanMode.
func ParseClimateFanMode(name string) (ClimateFanMode, error) {
	if x, ok := _ClimateFanModeValue[name]; ok {
		return x, nil
	}
	return ClimateFanMode(0), fmt.Errorf("%s is %w", name, ErrInvalidClimateFanMode)
}

// MarshalText implements the text marshaller method.
func (x ClimateFanMode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ClimateFanMode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseClimateFanMode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ClimateModeOff is a ClimateMode of type Off.
	ClimateModeOff ClimateMode = iota
	// ClimateModeHeatCool is a ClimateMode of type Heat_cool.
	ClimateModeHeatCool
	// ClimateModeCool is a ClimateMode of type Cool.
	ClimateModeCool
	// ClimateModeHeat is a ClimateMode of type Heat.
	ClimateModeHeat
	// ClimateModeFanOnly is a ClimateMode of type Fan_only.
	ClimateModeFanOnly
	// ClimateModeDry is a ClimateMode of type Dry.
	ClimateModeDry
	// ClimateModeAuto is a ClimateMode of type Auto.
	ClimateModeAuto
)

var ErrInvalidClimateMode = fmt.Errorf("not a valid ClimateMode, try [%s]", strings.Join(_ClimateModeNames, ", "))

const _ClimateModeName = "offheat_coolcoolheatfan_onlydryauto"

var _ClimateModeNames = []string{
	_ClimateModeName[0:3],
	_ClimateModeName[3:12],
	_ClimateModeName[12:16],
	_ClimateModeName[16:20],
	_ClimateModeName[20:28],
	_ClimateModeName[28:31],
	_ClimateModeName[31:35],
}

// ClimateModeNames returns a list of possible string values of ClimateMode.
func ClimateModeNames() []string {
	tmp := make([]string, len(_ClimateModeNames))
	copy(tmp, _ClimateModeNames)
	return tmp
}

// ClimateModeValues returns a list of the values for ClimateMode
func ClimateModeValues() []ClimateMode {
	return []ClimateMode{
		ClimateModeOff,
		ClimateModeHeatCool,
		ClimateModeCool,
		ClimateModeHeat,
		ClimateModeFanOnly,
		ClimateModeDry,
		ClimateModeAuto,
	}
}

var _ClimateModeMap = map[ClimateMode]string{
	ClimateModeOff:      _ClimateModeName[0:3],
	ClimateModeHeatCool: _ClimateModeName[3:12],
	ClimateModeCool:     _ClimateModeName[12:16],
	ClimateModeHeat:     _ClimateModeName[16:20],
	ClimateModeFanOnly:  _ClimateModeName[20:28],
	ClimateModeDry:      _ClimateModeName[28:31],
	ClimateModeAuto:     _ClimateModeName[31:35],
}

// String implements the Stringer interface.
func (x ClimateMode) String() string {
	if str, ok := _ClimateModeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ClimateMode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ClimateMode) IsValid() bool {
	_, ok := _ClimateModeMap[x]
	return ok
}

var _ClimateModeValue = map[string]ClimateMode{
	_ClimateModeName[0:3]:   ClimateModeOff,
	_ClimateModeName[3:12]:  ClimateModeHeatCool,
	_ClimateModeName[12:16]: ClimateModeCool,
	_ClimateModeName[16:20]: ClimateModeHeat,
	_ClimateModeName[20:28]: ClimateModeFanOnly,
	_ClimateModeName[28:31]: ClimateModeDry,
	_ClimateModeName[31:35]: ClimateModeAuto,
}

// ParseClimateMode attempts to convert a string to a ClimateMode.
func ParseClimateMode(name string) (ClimateMode, error) {
	if x, ok := _ClimateModeValue[name]; ok {
		return x, nil
	}
	return ClimateMode(0), fmt.Errorf("%s is %w", name, ErrInvalidClimateMode)
}

// MarshalText implements the text marshaller method.
func (x ClimateMode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ClimateMode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseClimateMode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ClimatePresetNone is a ClimatePreset of type None.
	ClimatePresetNone ClimatePreset = iota
	// ClimatePresetHome is a ClimatePreset of type Home.
	ClimatePresetHome
	// ClimatePresetAway is a ClimatePreset of type Away.
	ClimatePresetAway
	// ClimatePresetBoost is a ClimatePreset of type Boost.
	ClimatePresetBoost
	// ClimatePresetComfort is a ClimatePreset of type Comfort.
	ClimatePresetComfort
	// ClimatePresetEco is a ClimatePreset of type Eco.
	ClimatePresetEco
	// ClimatePresetSleep is a ClimatePreset of type Sleep.
	ClimatePresetSleep
	// ClimatePresetActivity is a ClimatePreset of type Activity.
	ClimatePresetActivity
)

var ErrInvalidClimatePreset = fmt.Errorf("not a valid ClimatePreset, try [%s]", strings.Join(_ClimatePresetNames, ", "))

const _ClimatePresetName = "nonehomeawayboostcomfortecosleepactivity"

var _ClimatePresetNames = []string{
	_ClimatePresetName[0:4],
	_ClimatePresetName[4:8],
	_ClimatePresetName[8:12],
	_ClimatePresetName[12:17],
	_ClimatePresetName[17:24],
	_ClimatePresetName[24:27],
	_ClimatePresetName[27:32],
	_ClimatePresetName[32:40],
}

// ClimatePresetNames returns a list of possible string values of ClimatePreset.
func ClimatePresetNames() []string {
	tmp := make([]string, len(_ClimatePresetNames))
	copy(tmp, _ClimatePresetNames)
	return tmp
}

// ClimatePresetValues returns a list of the values for ClimatePreset
func ClimatePresetValues() []ClimatePreset {
	return []ClimatePreset{
		ClimatePresetNone,
		ClimatePresetHome,
		ClimatePresetAway,
		ClimatePresetBoost,
		ClimatePresetComfort,
		ClimatePresetEco,
		ClimatePresetSleep,
		ClimatePresetActivity,
	}
}

var _ClimatePresetMap = map[ClimatePreset]string{
	ClimatePresetNone:     _ClimatePresetName[0:4],
	ClimatePresetHome:     _ClimatePresetName[4:8],
	ClimatePresetAway:     _ClimatePresetName[8:12],
	ClimatePresetBoost:    _ClimatePresetName[12:17],
	ClimatePresetComfort:  _ClimatePresetName[17:24],
	ClimatePresetEco:      _ClimatePresetName[24:27],
	ClimatePresetSleep:    _ClimatePresetName[27:32],
	ClimatePresetActivity: _ClimatePresetName[32:40],
}

// String implements the Stringer interface.
func (x ClimatePreset) String() string {
	if str, ok := _ClimatePresetMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ClimatePreset(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ClimatePreset) IsValid() bool {
	_, ok := _ClimatePresetMap[x]
	return ok
}

var _ClimatePresetValue = map[string]ClimatePreset{
	_ClimatePresetName[0:4]:   ClimatePresetNone,
	_ClimatePresetName[4:8]:   ClimatePresetHome,
	_ClimatePresetName[8:12]:  ClimatePresetAway,
	_ClimatePresetName[12:17]: ClimatePresetBoost,
	_ClimatePresetName[17:24]: ClimatePresetComfort,
	_ClimatePresetName[24:27]: ClimatePresetEco,
	_ClimatePresetName[27:32]: ClimatePresetSleep,
	_ClimatePresetName[32:40]: ClimatePresetActivity,
}

// ParseClimatePreset attempts to convert a string to a ClimatePreset.
func ParseClimatePreset(name string) (ClimatePreset, error) {
	if x, ok := _ClimatePresetValue[name]; ok {
		return x, nil
	}
	return ClimatePreset(0), fmt.Errorf("%s is %w", name, ErrInvalidClimatePreset)
}

// MarshalText implements the text marshaller method.
func (x ClimatePreset) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ClimatePreset) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseClimatePreset(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ClimateSwingModeOff is a ClimateSwingMode of type Off.
	ClimateSwingModeOff ClimateSwingMode = iota
	// ClimateSwingModeBoth is a ClimateSwingMode of type Both.
	ClimateSwingModeBoth
	// ClimateSwingModeVertical is a ClimateSwingMode of type Vertical.
	ClimateSwingModeVertical
	// ClimateSwingModeHorizontal is a ClimateSwingMode of type Horizontal.
	ClimateSwingModeHorizontal
)

var ErrInvalidClimateSwingMode = fmt.Errorf("not a valid ClimateSwingMode, try [%s]", strings.Join(_ClimateSwingModeNames, ", "))

const _ClimateSwingModeName = "offbothverticalhorizontal"

var _ClimateSwingModeNames = []string{
	_ClimateSwingModeName[0:3],
	_ClimateSwingModeName[3:7],
	_ClimateSwingModeName[7:15],
	_ClimateSwingModeName[15:25],
}

// ClimateSwingModeNames returns a list of possible string values of ClimateSwingMode.
func ClimateSwingModeNames() []string {
	tmp := make([]string, len(_ClimateSwingModeNames))
	copy(tmp, _ClimateSwingModeNames)
	return tmp
}

// ClimateSwingModeValues returns a list of the values for ClimateSwingMode
func ClimateSwingModeValues() []ClimateSwingMode {
	return []ClimateSwingMode{
		ClimateSwingModeOff,
		ClimateSwingModeBoth,
		ClimateSwingModeVertical,
		ClimateSwingModeHorizontal,
	}
}

var _ClimateSwingModeMap = map[ClimateSwingMode]string{
	ClimateSwingModeOff:        _ClimateSwingModeName[0:3],
	ClimateSwingModeBoth:       _ClimateSwingModeName[3:7],
	ClimateSwingModeVertical:   _ClimateSwingModeName[7:15],
	ClimateSwingModeHorizontal: _ClimateSwingModeName[15:25],
}

// String implements the Stringer interface.
func (x ClimateSwingMode) String() string {
	if str, ok := _ClimateSwingModeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ClimateSwingMode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ClimateSwingMode) IsValid() bool {
	_, ok := _ClimateSwingModeMap[x]
	return ok
}

var _ClimateSwingModeValue = map[string]ClimateSwingMode{
	_ClimateSwingModeName[0:3]:   ClimateSwingModeOff,
	_ClimateSwingModeName[3:7]:   ClimateSwingModeBoth,
	_ClimateSwingModeName[7:15]:  ClimateSwingModeVertical,
	_ClimateSwingModeName[15:25]: ClimateSwingModeHorizontal,
}

// ParseClimateSwingMode attempts to convert a string to a ClimateSwingMode.
func ParseClimateSwingMode(name string) (ClimateSwingMode, error) {
	if x, ok := _ClimateSwingModeValue[name]; ok {
		return x, nil
	}
	return ClimateSwingMode(0), fmt.Errorf("%s is %w", name, ErrInvalidClimateSwingMode)
}

// MarshalText implements the text marshaller method.
func (x ClimateSwingMode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ClimateSwingMode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseClimateSwingMode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const ()

var ErrInvalidColorCapability = fmt.Errorf("not a valid ColorCapability, try [%s]", strings.Join(_ColorCapabilityNames, ", "))

const _ColorCapabilityName = ""

var _ColorCapabilityNames = []string{}

// ColorCapabilityNames returns a list of possible string values of ColorCapability.
func ColorCapabilityNames() []string {
	tmp := make([]string, len(_ColorCapabilityNames))
	copy(tmp, _ColorCapabilityNames)
	return tmp
}

// ColorCapabilityValues returns a list of the values for ColorCapability
func ColorCapabilityValues() []ColorCapability {
	return []ColorCapability{}
}

var _ColorCapabilityMap = map[ColorCapability]string{}

// String implements the Stringer interface.
func (x ColorCapability) String() string {
	if str, ok := _ColorCapabilityMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ColorCapability(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ColorCapability) IsValid() bool {
	_, ok := _ColorCapabilityMap[x]
	return ok
}

var _ColorCapabilityValue = map[string]ColorCapability{}

// ParseColorCapability attempts to convert a string to a ColorCapability.
func ParseColorCapability(name string) (ColorCapability, error) {
	if x, ok := _ColorCapabilityValue[name]; ok {
		return x, nil
	}
	return ColorCapability(0), fmt.Errorf("%s is %w", name, ErrInvalidColorCapability)
}

// MarshalText implements the text marshaller method.
func (x ColorCapability) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ColorCapability) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseColorCapability(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// CoverDeviceClassAwning is a CoverDeviceClass of type awning.
	// Control of an awning, such as an exterior retractible window, door, or patio cover.
	CoverDeviceClassAwning CoverDeviceClass = "awning"
	// CoverDeviceClassBlind is a CoverDeviceClass of type blind.
	// Control of blinds, which are linked slats that expand or collapse to cover an opening or may be tilted to partially cover an opening, such as window blinds.
	CoverDeviceClassBlind CoverDeviceClass = "blind"
	// CoverDeviceClassCurtain is a CoverDeviceClass of type curtain.
	// Control of curtains or drapes, which is often fabric hung above a window or door that can be drawn open.
	CoverDeviceClassCurtain CoverDeviceClass = "curtain"
	// CoverDeviceClassDamper is a CoverDeviceClass of type damper.
	// Control of a mechanical damper that reduces air flow, sound, or light.
	CoverDeviceClassDamper CoverDeviceClass = "damper"
	// CoverDeviceClassDoor is a CoverDeviceClass of type door.
	// Control of a door that provides access to an area which is typically part of a structure.
	CoverDeviceClassDoor CoverDeviceClass = "door"
	// CoverDeviceClassGarage is a CoverDeviceClass of type garage.
	// Control of a garage door that provides access to a garage.
	CoverDeviceClassGarage CoverDeviceClass = "garage"
	// CoverDeviceClassGate is a CoverDeviceClass of type gate.
	// Control of a gate that provides access to a driveway or other area. Gates are found outside of a structure and are typically part of a fence.
	CoverDeviceClassGate CoverDeviceClass = "gate"
	// CoverDeviceClassShade is a CoverDeviceClass of type shade.
	// Control of shades, which are a continuous plane of material or connected cells that expanded or collapsed over an opening, such as window shades.
	CoverDeviceClassShade CoverDeviceClass = "shade"
	// CoverDeviceClassShutter is a CoverDeviceClass of type shutter.
	// Control of shutters, which are linked slats that swing out/in to cover an opening or may be tilted to partially cover an opening, such as indoor or exterior window shutters.
	CoverDeviceClassShutter CoverDeviceClass = "shutter"
	// CoverDeviceClassWindow is a CoverDeviceClass of type window.
	// Control of a physical window that opens and closes or may tilt.
	CoverDeviceClassWindow CoverDeviceClass = "window"
)

var ErrInvalidCoverDeviceClass = fmt.Errorf("not a valid CoverDeviceClass, try [%s]", strings.Join(_CoverDeviceClassNames, ", "))

var _CoverDeviceClassNames = []string{
	string(CoverDeviceClassAwning),
	string(CoverDeviceClassBlind),
	string(CoverDeviceClassCurtain),
	string(CoverDeviceClassDamper),
	string(CoverDeviceClassDoor),
	string(CoverDeviceClassGarage),
	string(CoverDeviceClassGate),
	string(CoverDeviceClassShade),
	string(CoverDeviceClassShutter),
	string(CoverDeviceClassWindow),
}

// CoverDeviceClassNames returns a list of possible string values of CoverDeviceClass.
func CoverDeviceClassNames() []string {
	tmp := make([]string, len(_CoverDeviceClassNames))
	copy(tmp, _CoverDeviceClassNames)
	return tmp
}

// CoverDeviceClassValues returns a list of the values for CoverDeviceClass
func CoverDeviceClassValues() []CoverDeviceClass {
	return []CoverDeviceClass{
		CoverDeviceClassAwning,
		CoverDeviceClassBlind,
		CoverDeviceClassCurtain,
		CoverDeviceClassDamper,
		CoverDeviceClassDoor,
		CoverDeviceClassGarage,
		CoverDeviceClassGate,
		CoverDeviceClassShade,
		CoverDeviceClassShutter,
		CoverDeviceClassWindow,
	}
}

// String implements the Stringer interface.
func (x CoverDeviceClass) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CoverDeviceClass) IsValid() bool {
	_, err := ParseCoverDeviceClass(string(x))
	return err == nil
}

var _CoverDeviceClassValue = map[string]CoverDeviceClass{
	"awning":  CoverDeviceClassAwning,
	"blind":   CoverDeviceClassBlind,
	"curtain": CoverDeviceClassCurtain,
	"damper":  CoverDeviceClassDamper,
	"door":    CoverDeviceClassDoor,
	"garage":  CoverDeviceClassGarage,
	"gate":    CoverDeviceClassGate,
	"shade":   CoverDeviceClassShade,
	"shutter": CoverDeviceClassShutter,
	"window":  CoverDeviceClassWindow,
}

// ParseCoverDeviceClass attempts to convert a string to a CoverDeviceClass.
func ParseCoverDeviceClass(name string) (CoverDeviceClass, error) {
	if x, ok := _CoverDeviceClassValue[name]; ok {
		return x, nil
	}
	return CoverDeviceClass(""), fmt.Errorf("%s is %w", name, ErrInvalidCoverDeviceClass)
}

// MarshalText implements the text marshaller method.
func (x CoverDeviceClass) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *CoverDeviceClass) UnmarshalText(text []byte) error {
	tmp, err := ParseCoverDeviceClass(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// DomainTypeBinarySensor is a DomainType of type Binary_sensor.
	DomainTypeBinarySensor DomainType = iota
	// DomainTypeCover is a DomainType of type Cover.
	DomainTypeCover
	// DomainTypeFan is a DomainType of type Fan.
	DomainTypeFan
	// DomainTypeLight is a DomainType of type Light.
	DomainTypeLight
	// DomainTypeSensor is a DomainType of type Sensor.
	DomainTypeSensor
	// DomainTypeSwitch is a DomainType of type Switch.
	DomainTypeSwitch
	// DomainTypeButton is a DomainType of type Button.
	DomainTypeButton
	// DomainTypeTextSensor is a DomainType of type Text_sensor.
	DomainTypeTextSensor
	// DomainTypeService is a DomainType of type Service.
	DomainTypeService
	// DomainTypeCamera is a DomainType of type Camera.
	DomainTypeCamera
	// DomainTypeClimate is a DomainType of type Climate.
	DomainTypeClimate
	// DomainTypeNumber is a DomainType of type Number.
	DomainTypeNumber
	// DomainTypeDatetimeDate is a DomainType of type Datetime_date.
	DomainTypeDatetimeDate
	// DomainTypeDatetimeTime is a DomainType of type Datetime_time.
	DomainTypeDatetimeTime
	// DomainTypeDatetimeDatetime is a DomainType of type Datetime_datetime.
	DomainTypeDatetimeDatetime
	// DomainTypeText is a DomainType of type Text.
	DomainTypeText
	// DomainTypeSelect is a DomainType of type Select.
	DomainTypeSelect
	// DomainTypeLock is a DomainType of type Lock.
	DomainTypeLock
	// DomainTypeValve is a DomainType of type Valve.
	DomainTypeValve
	// DomainTypeMediaPlayer is a DomainType of type Media_player.
	DomainTypeMediaPlayer
	// DomainTypeAlarmControlPanel is a DomainType of type Alarm_control_panel.
	DomainTypeAlarmControlPanel
	// DomainTypeSiren is a DomainType of type Siren.
	DomainTypeSiren
	// DomainTypeEvent is a DomainType of type Event.
	DomainTypeEvent
	// DomainTypeUpdate is a DomainType of type Update.
	DomainTypeUpdate
)

var ErrInvalidDomainType = fmt.Errorf("not a valid DomainType, try [%s]", strings.Join(_DomainTypeNames, ", "))

const _DomainTypeName = "binary_sensorcoverfanlightsensorswitchbuttontext_sensorservicecameraclimatenumberdatetime_datedatetime_timedatetime_datetimetextselectlockvalvemedia_playeralarm_control_panelsireneventupdate"

var _DomainTypeNames = []string{
	_DomainTypeName[0:13],
	_DomainTypeName[13:18],
	_DomainTypeName[18:21],
	_DomainTypeName[21:26],
	_DomainTypeName[26:32],
	_DomainTypeName[32:38],
	_DomainTypeName[38:44],
	_DomainTypeName[44:55],
	_DomainTypeName[55:62],
	_DomainTypeName[62:68],
	_DomainTypeName[68:75],
	_DomainTypeName[75:81],
	_DomainTypeName[81:94],
	_DomainTypeName[94:107],
	_DomainTypeName[107:124],
	_DomainTypeName[124:128],
	_DomainTypeName[128:134],
	_DomainTypeName[134:138],
	_DomainTypeName[138:143],
	_DomainTypeName[143:155],
	_DomainTypeName[155:174],
	_DomainTypeName[174:179],
	_DomainTypeName[179:184],
	_DomainTypeName[184:190],
}

// DomainTypeNames returns a list of possible string values of DomainType.
func DomainTypeNames() []string {
	tmp := make([]string, len(_DomainTypeNames))
	copy(tmp, _DomainTypeNames)
	return tmp
}

// DomainTypeValues returns a list of the values for DomainType
func DomainTypeValues() []DomainType {
	return []DomainType{
		DomainTypeBinarySensor,
		DomainTypeCover,
		DomainTypeFan,
		DomainTypeLight,
		DomainTypeSensor,
		DomainTypeSwitch,
		DomainTypeButton,
		DomainTypeTextSensor,
		DomainTypeService,
		DomainTypeCamera,
		DomainTypeClimate,
		DomainTypeNumber,
		DomainTypeDatetimeDate,
		DomainTypeDatetimeTime,
		DomainTypeDatetimeDatetime,
		DomainTypeText,
		DomainTypeSelect,
		DomainTypeLock,
		DomainTypeValve,
		DomainTypeMediaPlayer,
		DomainTypeAlarmControlPanel,
		DomainTypeSiren,
		DomainTypeEvent,
		DomainTypeUpdate,
	}
}

var _DomainTypeMap = map[DomainType]string{
	DomainTypeBinarySensor:      _DomainTypeName[0:13],
	DomainTypeCover:             _DomainTypeName[13:18],
	DomainTypeFan:               _DomainTypeName[18:21],
	DomainTypeLight:             _DomainTypeName[21:26],
	DomainTypeSensor:            _DomainTypeName[26:32],
	DomainTypeSwitch:            _DomainTypeName[32:38],
	DomainTypeButton:            _DomainTypeName[38:44],
	DomainTypeTextSensor:        _DomainTypeName[44:55],
	DomainTypeService:           _DomainTypeName[55:62],
	DomainTypeCamera:            _DomainTypeName[62:68],
	DomainTypeClimate:           _DomainTypeName[68:75],
	DomainTypeNumber:            _DomainTypeName[75:81],
	DomainTypeDatetimeDate:      _DomainTypeName[81:94],
	DomainTypeDatetimeTime:      _DomainTypeName[94:107],
	DomainTypeDatetimeDatetime:  _DomainTypeName[107:124],
	DomainTypeText:              _DomainTypeName[124:128],
	DomainTypeSelect:            _DomainTypeName[128:134],
	DomainTypeLock:              _DomainTypeName[134:138],
	DomainTypeValve:             _DomainTypeName[138:143],
	DomainTypeMediaPlayer:       _DomainTypeName[143:155],
	DomainTypeAlarmControlPanel: _DomainTypeName[155:174],
	DomainTypeSiren:             _DomainTypeName[174:179],
	DomainTypeEvent:             _DomainTypeName[179:184],
	DomainTypeUpdate:            _DomainTypeName[184:190],
}

// String implements the Stringer interface.
func (x DomainType) String() string {
	if str, ok := _DomainTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("DomainType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DomainType) IsValid() bool {
	_, ok := _DomainTypeMap[x]
	return ok
}

var _DomainTypeValue = map[string]DomainType{
	_DomainTypeName[0:13]:    DomainTypeBinarySensor,
	_DomainTypeName[13:18]:   DomainTypeCover,
	_DomainTypeName[18:21]:   DomainTypeFan,
	_DomainTypeName[21:26]:   DomainTypeLight,
	_DomainTypeName[26:32]:   DomainTypeSensor,
	_DomainTypeName[32:38]:   DomainTypeSwitch,
	_DomainTypeName[38:44]:   DomainTypeButton,
	_DomainTypeName[44:55]:   DomainTypeTextSensor,
	_DomainTypeName[55:62]:   DomainTypeService,
	_DomainTypeName[62:68]:   DomainTypeCamera,
	_DomainTypeName[68:75]:   DomainTypeClimate,
	_DomainTypeName[75:81]:   DomainTypeNumber,
	_DomainTypeName[81:94]:   DomainTypeDatetimeDate,
	_DomainTypeName[94:107]:  DomainTypeDatetimeTime,
	_DomainTypeName[107:124]: DomainTypeDatetimeDatetime,
	_DomainTypeName[124:128]: DomainTypeText,
	_DomainTypeName[128:134]: DomainTypeSelect,
	_DomainTypeName[134:138]: DomainTypeLock,
	_DomainTypeName[138:143]: DomainTypeValve,
	_DomainTypeName[143:155]: DomainTypeMediaPlayer,
	_DomainTypeName[155:174]: DomainTypeAlarmControlPanel,
	_DomainTypeName[174:179]: DomainTypeSiren,
	_DomainTypeName[179:184]: DomainTypeEvent,
	_DomainTypeName[184:190]: DomainTypeUpdate,
}

// ParseDomainType attempts to convert a string to a DomainType.
func ParseDomainType(name string) (DomainType, error) {
	if x, ok := _DomainTypeValue[name]; ok {
		return x, nil
	}
	return DomainType(0), fmt.Errorf("%s is %w", name, ErrInvalidDomainType)
}

// MarshalText implements the text marshaller method.
func (x DomainType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *DomainType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseDomainType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// FanDirectionForwardreverse is a FanDirection of type Forward.reverse.
	FanDirectionForwardreverse FanDirection = iota
)

var ErrInvalidFanDirection = fmt.Errorf("not a valid FanDirection, try [%s]", strings.Join(_FanDirectionNames, ", "))

const _FanDirectionName = "forward.reverse"

var _FanDirectionNames = []string{
	_FanDirectionName[0:15],
}

// FanDirectionNames returns a list of possible string values of FanDirection.
func FanDirectionNames() []string {
	tmp := make([]string, len(_FanDirectionNames))
	copy(tmp, _FanDirectionNames)
	return tmp
}

// FanDirectionValues returns a list of the values for FanDirection
func FanDirectionValues() []FanDirection {
	return []FanDirection{
		FanDirectionForwardreverse,
	}
}

var _FanDirectionMap = map[FanDirection]string{
	FanDirectionForwardreverse: _FanDirectionName[0:15],
}

// String implements the Stringer interface.
func (x FanDirection) String() string {
	if str, ok := _FanDirectionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("FanDirection(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x FanDirection) IsValid() bool {
	_, ok := _FanDirectionMap[x]
	return ok
}

var _FanDirectionValue = map[string]FanDirection{
	_FanDirectionName[0:15]: FanDirectionForwardreverse,
}

// ParseFanDirection attempts to convert a string to a FanDirection.
func ParseFanDirection(name string) (FanDirection, error) {
	if x, ok := _FanDirectionValue[name]; ok {
		return x, nil
	}
	return FanDirection(0), fmt.Errorf("%s is %w", name, ErrInvalidFanDirection)
}

// MarshalText implements the text marshaller method.
func (x FanDirection) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *FanDirection) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseFanDirection(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// FanSpeedLow is a FanSpeed of type Low.
	FanSpeedLow FanSpeed = iota
	// FanSpeedMedium is a FanSpeed of type Medium.
	FanSpeedMedium
	// FanSpeedHigh is a FanSpeed of type High.
	FanSpeedHigh
)

var ErrInvalidFanSpeed = fmt.Errorf("not a valid FanSpeed, try [%s]", strings.Join(_FanSpeedNames, ", "))

const _FanSpeedName = "lowmediumhigh"

var _FanSpeedNames = []string{
	_FanSpeedName[0:3],
	_FanSpeedName[3:9],
	_FanSpeedName[9:13],
}

// FanSpeedNames returns a list of possible string values of FanSpeed.
func FanSpeedNames() []string {
	tmp := make([]string, len(_FanSpeedNames))
	copy(tmp, _FanSpeedNames)
	return tmp
}

// FanSpeedValues returns a list of the values for FanSpeed
func FanSpeedValues() []FanSpeed {
	return []FanSpeed{
		FanSpeedLow,
		FanSpeedMedium,
		FanSpeedHigh,
	}
}

var _FanSpeedMap = map[FanSpeed]string{
	FanSpeedLow:    _FanSpeedName[0:3],
	FanSpeedMedium: _FanSpeedName[3:9],
	FanSpeedHigh:   _FanSpeedName[9:13],
}

// String implements the Stringer interface.
func (x FanSpeed) String() string {
	if str, ok := _FanSpeedMap[x]; ok {
		return str
	}
	return fmt.Sprintf("FanSpeed(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x FanSpeed) IsValid() bool {
	_, ok := _FanSpeedMap[x]
	return ok
}

var _FanSpeedValue = map[string]FanSpeed{
	_FanSpeedName[0:3]:  FanSpeedLow,
	_FanSpeedName[3:9]:  FanSpeedMedium,
	_FanSpeedName[9:13]: FanSpeedHigh,
}

// ParseFanSpeed attempts to convert a string to a FanSpeed.
func ParseFanSpeed(name string) (FanSpeed, error) {
	if x, ok := _FanSpeedValue[name]; ok {
		return x, nil
	}
	return FanSpeed(0), fmt.Errorf("%s is %w", name, ErrInvalidFanSpeed)
}

// MarshalText implements the text marshaller method.
func (x FanSpeed) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *FanSpeed) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseFanSpeed(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// LegacyCoverStateOpen is a LegacyCoverState of type Open.
	LegacyCoverStateOpen LegacyCoverState = iota
	// LegacyCoverStateClosed is a LegacyCoverState of type Closed.
	LegacyCoverStateClosed
)

var ErrInvalidLegacyCoverState = fmt.Errorf("not a valid LegacyCoverState, try [%s]", strings.Join(_LegacyCoverStateNames, ", "))

const _LegacyCoverStateName = "openclosed"

var _LegacyCoverStateNames = []string{
	_LegacyCoverStateName[0:4],
	_LegacyCoverStateName[4:10],
}

// LegacyCoverStateNames returns a list of possible string values of LegacyCoverState.
func LegacyCoverStateNames() []string {
	tmp := make([]string, len(_LegacyCoverStateNames))
	copy(tmp, _LegacyCoverStateNames)
	return tmp
}

// LegacyCoverStateValues returns a list of the values for LegacyCoverState
func LegacyCoverStateValues() []LegacyCoverState {
	return []LegacyCoverState{
		LegacyCoverStateOpen,
		LegacyCoverStateClosed,
	}
}

var _LegacyCoverStateMap = map[LegacyCoverState]string{
	LegacyCoverStateOpen:   _LegacyCoverStateName[0:4],
	LegacyCoverStateClosed: _LegacyCoverStateName[4:10],
}

// String implements the Stringer interface.
func (x LegacyCoverState) String() string {
	if str, ok := _LegacyCoverStateMap[x]; ok {
		return str
	}
	return fmt.Sprintf("LegacyCoverState(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LegacyCoverState) IsValid() bool {
	_, ok := _LegacyCoverStateMap[x]
	return ok
}

var _LegacyCoverStateValue = map[string]LegacyCoverState{
	_LegacyCoverStateName[0:4]:  LegacyCoverStateOpen,
	_LegacyCoverStateName[4:10]: LegacyCoverStateClosed,
}

// ParseLegacyCoverState attempts to convert a string to a LegacyCoverState.
func ParseLegacyCoverState(name string) (LegacyCoverState, error) {
	if x, ok := _LegacyCoverStateValue[name]; ok {
		return x, nil
	}
	return LegacyCoverState(0), fmt.Errorf("%s is %w", name, ErrInvalidLegacyCoverState)
}

// MarshalText implements the text marshaller method.
func (x LegacyCoverState) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LegacyCoverState) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseLegacyCoverState(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// LockStateNone is a LockState of type None.
	LockStateNone LockState = iota
	// LockStateLocked is a LockState of type Locked.
	LockStateLocked
	// LockStateUnlocked is a LockState of type Unlocked.
	LockStateUnlocked
	// LockStateJammed is a LockState of type Jammed.
	LockStateJammed
	// LockStateLocking is a LockState of type Locking.
	LockStateLocking
	// LockStateUnlocking is a LockState of type Unlocking.
	LockStateUnlocking
)

var ErrInvalidLockState = fmt.Errorf("not a valid LockState, try [%s]", strings.Join(_LockStateNames, ", "))

const _LockStateName = "nonelockedunlockedjammedlockingunlocking"

var _LockStateNames = []string{
	_LockStateName[0:4],
	_LockStateName[4:10],
	_LockStateName[10:18],
	_LockStateName[18:24],
	_LockStateName[24:31],
	_LockStateName[31:40],
}

// LockStateNames returns a list of possible string values of LockState.
func LockStateNames() []string {
	tmp := make([]string, len(_LockStateNames))
	copy(tmp, _LockStateNames)
	return tmp
}

// LockStateValues returns a list of the values for LockState
func LockStateValues() []LockState {
	return []LockState{
		LockStateNone,
		LockStateLocked,
		LockStateUnlocked,
		LockStateJammed,
		LockStateLocking,
		LockStateUnlocking,
	}
}

var _LockStateMap = map[LockState]string{
	LockStateNone:      _LockStateName[0:4],
	LockStateLocked:    _LockStateName[4:10],
	LockStateUnlocked:  _LockStateName[10:18],
	LockStateJammed:    _LockStateName[18:24],
	LockStateLocking:   _LockStateName[24:31],
	LockStateUnlocking: _LockStateName[31:40],
}

// String implements the Stringer interface.
func (x LockState) String() string {
	if str, ok := _LockStateMap[x]; ok {
		return str
	}
	return fmt.Sprintf("LockState(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LockState) IsValid() bool {
	_, ok := _LockStateMap[x]
	return ok
}

var _LockStateValue = map[string]LockState{
	_LockStateName[0:4]:   LockStateNone,
	_LockStateName[4:10]:  LockStateLocked,
	_LockStateName[10:18]: LockStateUnlocked,
	_LockStateName[18:24]: LockStateJammed,
	_LockStateName[24:31]: LockStateLocking,
	_LockStateName[31:40]: LockStateUnlocking,
}

// ParseLockState attempts to convert a string to a LockState.
func ParseLockState(name string) (LockState, error) {
	if x, ok := _LockStateValue[name]; ok {
		return x, nil
	}
	return LockState(0), fmt.Errorf("%s is %w", name, ErrInvalidLockState)
}

// MarshalText implements the text marshaller method.
func (x LockState) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LockState) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseLockState(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MediaPlayerFormatPurposeDefault is a MediaPlayerFormatPurpose of type Default.
	MediaPlayerFormatPurposeDefault MediaPlayerFormatPurpose = iota
	// MediaPlayerFormatPurposeAnnouncement is a MediaPlayerFormatPurpose of type Announcement.
	MediaPlayerFormatPurposeAnnouncement
)

var ErrInvalidMediaPlayerFormatPurpose = fmt.Errorf("not a valid MediaPlayerFormatPurpose, try [%s]", strings.Join(_MediaPlayerFormatPurposeNames, ", "))

const _MediaPlayerFormatPurposeName = "defaultannouncement"

var _MediaPlayerFormatPurposeNames = []string{
	_MediaPlayerFormatPurposeName[0:7],
	_MediaPlayerFormatPurposeName[7:19],
}

// MediaPlayerFormatPurposeNames returns a list of possible string values of MediaPlayerFormatPurpose.
func MediaPlayerFormatPurposeNames() []string {
	tmp := make([]string, len(_MediaPlayerFormatPurposeNames))
	copy(tmp, _MediaPlayerFormatPurposeNames)
	return tmp
}

// MediaPlayerFormatPurposeValues returns a list of the values for MediaPlayerFormatPurpose
func MediaPlayerFormatPurposeValues() []MediaPlayerFormatPurpose {
	return []MediaPlayerFormatPurpose{
		MediaPlayerFormatPurposeDefault,
		MediaPlayerFormatPurposeAnnouncement,
	}
}

var _MediaPlayerFormatPurposeMap = map[MediaPlayerFormatPurpose]string{
	MediaPlayerFormatPurposeDefault:      _MediaPlayerFormatPurposeName[0:7],
	MediaPlayerFormatPurposeAnnouncement: _MediaPlayerFormatPurposeName[7:19],
}

// String implements the Stringer interface.
func (x MediaPlayerFormatPurpose) String() string {
	if str, ok := _MediaPlayerFormatPurposeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MediaPlayerFormatPurpose(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MediaPlayerFormatPurpose) IsValid() bool {
	_, ok := _MediaPlayerFormatPurposeMap[x]
	return ok
}

var _MediaPlayerFormatPurposeValue = map[string]MediaPlayerFormatPurpose{
	_MediaPlayerFormatPurposeName[0:7]:  MediaPlayerFormatPurposeDefault,
	_MediaPlayerFormatPurposeName[7:19]: MediaPlayerFormatPurposeAnnouncement,
}

// ParseMediaPlayerFormatPurpose attempts to convert a string to a MediaPlayerFormatPurpose.
func ParseMediaPlayerFormatPurpose(name string) (MediaPlayerFormatPurpose, error) {
	if x, ok := _MediaPlayerFormatPurposeValue[name]; ok {
		return x, nil
	}
	return MediaPlayerFormatPurpose(0), fmt.Errorf("%s is %w", name, ErrInvalidMediaPlayerFormatPurpose)
}

// MarshalText implements the text marshaller method.
func (x MediaPlayerFormatPurpose) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MediaPlayerFormatPurpose) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMediaPlayerFormatPurpose(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MediaPlayingStateNone is a MediaPlayingState of type None.
	MediaPlayingStateNone MediaPlayingState = iota
	// MediaPlayingStateIdle is a MediaPlayingState of type Idle.
	MediaPlayingStateIdle
	// MediaPlayingStatePlaying is a MediaPlayingState of type Playing.
	MediaPlayingStatePlaying
	// MediaPlayingStatePaused is a MediaPlayingState of type Paused.
	MediaPlayingStatePaused
)

var ErrInvalidMediaPlayingState = fmt.Errorf("not a valid MediaPlayingState, try [%s]", strings.Join(_MediaPlayingStateNames, ", "))

const _MediaPlayingStateName = "noneidleplayingpaused"

var _MediaPlayingStateNames = []string{
	_MediaPlayingStateName[0:4],
	_MediaPlayingStateName[4:8],
	_MediaPlayingStateName[8:15],
	_MediaPlayingStateName[15:21],
}

// MediaPlayingStateNames returns a list of possible string values of MediaPlayingState.
func MediaPlayingStateNames() []string {
	tmp := make([]string, len(_MediaPlayingStateNames))
	copy(tmp, _MediaPlayingStateNames)
	return tmp
}

// MediaPlayingStateValues returns a list of the values for MediaPlayingState
func MediaPlayingStateValues() []MediaPlayingState {
	return []MediaPlayingState{
		MediaPlayingStateNone,
		MediaPlayingStateIdle,
		MediaPlayingStatePlaying,
		MediaPlayingStatePaused,
	}
}

var _MediaPlayingStateMap = map[MediaPlayingState]string{
	MediaPlayingStateNone:    _MediaPlayingStateName[0:4],
	MediaPlayingStateIdle:    _MediaPlayingStateName[4:8],
	MediaPlayingStatePlaying: _MediaPlayingStateName[8:15],
	MediaPlayingStatePaused:  _MediaPlayingStateName[15:21],
}

// String implements the Stringer interface.
func (x MediaPlayingState) String() string {
	if str, ok := _MediaPlayingStateMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MediaPlayingState(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MediaPlayingState) IsValid() bool {
	_, ok := _MediaPlayingStateMap[x]
	return ok
}

var _MediaPlayingStateValue = map[string]MediaPlayingState{
	_MediaPlayingStateName[0:4]:   MediaPlayingStateNone,
	_MediaPlayingStateName[4:8]:   MediaPlayingStateIdle,
	_MediaPlayingStateName[8:15]:  MediaPlayingStatePlaying,
	_MediaPlayingStateName[15:21]: MediaPlayingStatePaused,
}

// ParseMediaPlayingState attempts to convert a string to a MediaPlayingState.
func ParseMediaPlayingState(name string) (MediaPlayingState, error) {
	if x, ok := _MediaPlayingStateValue[name]; ok {
		return x, nil
	}
	return MediaPlayingState(0), fmt.Errorf("%s is %w", name, ErrInvalidMediaPlayingState)
}

// MarshalText implements the text marshaller method.
func (x MediaPlayingState) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MediaPlayingState) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMediaPlayingState(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NumberModeAuto is a NumberMode of type Auto.
	NumberModeAuto NumberMode = iota
	// NumberModeBox is a NumberMode of type Box.
	NumberModeBox
	// NumberModeSlider is a NumberMode of type Slider.
	NumberModeSlider
)

var ErrInvalidNumberMode = fmt.Errorf("not a valid NumberMode, try [%s]", strings.Join(_NumberModeNames, ", "))

const _NumberModeName = "autoboxslider"

var _NumberModeNames = []string{
	_NumberModeName[0:4],
	_NumberModeName[4:7],
	_NumberModeName[7:13],
}

// NumberModeNames returns a list of possible string values of NumberMode.
func NumberModeNames() []string {
	tmp := make([]string, len(_NumberModeNames))
	copy(tmp, _NumberModeNames)
	return tmp
}

// NumberModeValues returns a list of the values for NumberMode
func NumberModeValues() []NumberMode {
	return []NumberMode{
		NumberModeAuto,
		NumberModeBox,
		NumberModeSlider,
	}
}

var _NumberModeMap = map[NumberMode]string{
	NumberModeAuto:   _NumberModeName[0:4],
	NumberModeBox:    _NumberModeName[4:7],
	NumberModeSlider: _NumberModeName[7:13],
}

// String implements the Stringer interface.
func (x NumberMode) String() string {
	if str, ok := _NumberModeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NumberMode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x NumberMode) IsValid() bool {
	_, ok := _NumberModeMap[x]
	return ok
}

var _NumberModeValue = map[string]NumberMode{
	_NumberModeName[0:4]:  NumberModeAuto,
	_NumberModeName[4:7]:  NumberModeBox,
	_NumberModeName[7:13]: NumberModeSlider,
}

// ParseNumberMode attempts to convert a string to a NumberMode.
func ParseNumberMode(name string) (NumberMode, error) {
	if x, ok := _NumberModeValue[name]; ok {
		return x, nil
	}
	return NumberMode(0), fmt.Errorf("%s is %w", name, ErrInvalidNumberMode)
}

// MarshalText implements the text marshaller method.
func (x NumberMode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *NumberMode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNumberMode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SensorDeviceClassApparentPower is a SensorDeviceClass of type apparent_power.
	// Apparent power
	SensorDeviceClassApparentPower SensorDeviceClass = "apparent_power"
	// SensorDeviceClassAqi is a SensorDeviceClass of type aqi.
	// Air Quality Index
	SensorDeviceClassAqi SensorDeviceClass = "aqi"
	// SensorDeviceClassArea is a SensorDeviceClass of type area.
	// Area
	SensorDeviceClassArea SensorDeviceClass = "area"
	// SensorDeviceClassAtmosphericPressure is a SensorDeviceClass of type atmospheric_pressure.
	// Atmospheric pressure
	SensorDeviceClassAtmosphericPressure SensorDeviceClass = "atmospheric_pressure"
	// SensorDeviceClassBattery is a SensorDeviceClass of type battery.
	// Percentage of battery that is left
	SensorDeviceClassBattery SensorDeviceClass = "battery"
	// SensorDeviceClassBloodGlucoseConcentration is a SensorDeviceClass of type blood_glucose_concentration.
	// Blood glucose concentration```
	SensorDeviceClassBloodGlucoseConcentration SensorDeviceClass = "blood_glucose_concentration"
	// SensorDeviceClassCo2 is a SensorDeviceClass of type co2.
	// Concentration of carbon dioxide.
	SensorDeviceClassCo2 SensorDeviceClass = "co2"
	// SensorDeviceClassCo is a SensorDeviceClass of type co.
	// Concentration of carbon monoxide.
	SensorDeviceClassCo SensorDeviceClass = "co"
	// SensorDeviceClassConductivity is a SensorDeviceClass of type conductivity.
	// Conductivity
	SensorDeviceClassConductivity SensorDeviceClass = "conductivity"
	// SensorDeviceClassCurrent is a SensorDeviceClass of type current.
	// Current
	SensorDeviceClassCurrent SensorDeviceClass = "current"
	// SensorDeviceClassDataRate is a SensorDeviceClass of type data_rate.
	// Data rate
	SensorDeviceClassDataRate SensorDeviceClass = "data_rate"
	// SensorDeviceClassDataSize is a SensorDeviceClass of type data_size.
	// Data size
	SensorDeviceClassDataSize SensorDeviceClass = "data_size"
	// SensorDeviceClassDate is a SensorDeviceClass of type date.
	// Date. Requires native_value to be a Python datetime.date object, or None.
	SensorDeviceClassDate SensorDeviceClass = "date"
	// SensorDeviceClassDistance is a SensorDeviceClass of type distance.
	// Generic distance
	SensorDeviceClassDistance SensorDeviceClass = "distance"
	// SensorDeviceClassDuration is a SensorDeviceClass of type duration.
	// Time period. Should not update only due to time passing. The device or service needs to give a new data point to update.
	SensorDeviceClassDuration SensorDeviceClass = "duration"
	// SensorDeviceClassEnergy is a SensorDeviceClass of type energy.
	// Energy, this device class should be used for sensors representing energy consumption, for example an electricity meter. Represents power over time. Not to be confused with power.
	SensorDeviceClassEnergy SensorDeviceClass = "energy"
	// SensorDeviceClassEnergyDistance is a SensorDeviceClass of type energy_distance.
	// Energy per distance, this device class should be used to represent energy consumption by distance, for example the amount of electric energy consumed by an electric car.
	SensorDeviceClassEnergyDistance SensorDeviceClass = "energy_distance"
	// SensorDeviceClassEnergyStorage is a SensorDeviceClass of type energy_storage.
	// Stored energy, this device class should be used for sensors representing stored energy, for example the amount of electric energy currently stored in a battery or the capacity of a battery. Represents power over time. Not to be confused with power.
	SensorDeviceClassEnergyStorage SensorDeviceClass = "energy_storage"
	// SensorDeviceClassEnum is a SensorDeviceClass of type enum.
	// The sensor has a limited set of (non-numeric) states. The options property must be set to a list of possible states when using this device class.
	SensorDeviceClassEnum SensorDeviceClass = "enum"
	// SensorDeviceClassFrequency is a SensorDeviceClass of type frequency.
	// Frequency
	SensorDeviceClassFrequency SensorDeviceClass = "frequency"
	// SensorDeviceClassGas is a SensorDeviceClass of type gas.
	// Volume of gas. Gas consumption measured as energy in kWh instead of a volume should be classified as energy.
	SensorDeviceClassGas SensorDeviceClass = "gas"
	// SensorDeviceClassHumidity is a SensorDeviceClass of type humidity.
	// Relative humidity
	SensorDeviceClassHumidity SensorDeviceClass = "humidity"
	// SensorDeviceClassIlluminance is a SensorDeviceClass of type illuminance.
	// Light level
	SensorDeviceClassIlluminance SensorDeviceClass = "illuminance"
	// SensorDeviceClassIrradiance is a SensorDeviceClass of type irradiance.
	// Irradiance
	SensorDeviceClassIrradiance SensorDeviceClass = "irradiance"
	// SensorDeviceClassMoisture is a SensorDeviceClass of type moisture.
	// Moisture
	SensorDeviceClassMoisture SensorDeviceClass = "moisture"
	// SensorDeviceClassMonetary is a SensorDeviceClass of type monetary.
	// Monetary value with a currency.
	SensorDeviceClassMonetary SensorDeviceClass = "monetary"
	// SensorDeviceClassNitrogenDioxide is a SensorDeviceClass of type nitrogen_dioxide.
	// Concentration of nitrogen dioxide
	SensorDeviceClassNitrogenDioxide SensorDeviceClass = "nitrogen_dioxide"
	// SensorDeviceClassNitrogenMonoxide is a SensorDeviceClass of type nitrogen_monoxide.
	// Concentration of nitrogen monoxide
	SensorDeviceClassNitrogenMonoxide SensorDeviceClass = "nitrogen_monoxide"
	// SensorDeviceClassNitrousOxide is a SensorDeviceClass of type nitrous_oxide.
	// Concentration of nitrous oxide
	SensorDeviceClassNitrousOxide SensorDeviceClass = "nitrous_oxide"
	// SensorDeviceClassOzone is a SensorDeviceClass of type ozone.
	// Concentration of ozone
	SensorDeviceClassOzone SensorDeviceClass = "ozone"
	// SensorDeviceClassPh is a SensorDeviceClass of type ph.
	// Potential hydrogen (pH) of an aqueous solution
	SensorDeviceClassPh SensorDeviceClass = "ph"
	// SensorDeviceClassPm1 is a SensorDeviceClass of type pm1.
	// Concentration of particulate matter less than 1 micrometer
	SensorDeviceClassPm1 SensorDeviceClass = "pm1"
	// SensorDeviceClassPm25 is a SensorDeviceClass of type pm25.
	// Concentration of particulate matter less than 2.5 micrometers
	SensorDeviceClassPm25 SensorDeviceClass = "pm25"
	// SensorDeviceClassPm10 is a SensorDeviceClass of type pm10.
	// Concentration of particulate matter less than 10 micrometers
	SensorDeviceClassPm10 SensorDeviceClass = "pm10"
	// SensorDeviceClassPower is a SensorDeviceClass of type power.
	// Power.
	SensorDeviceClassPower SensorDeviceClass = "power"
	// SensorDeviceClassPowerFactor is a SensorDeviceClass of type power_factor.
	// Power Factor
	SensorDeviceClassPowerFactor SensorDeviceClass = "power_factor"
	// SensorDeviceClassPrecipitation is a SensorDeviceClass of type precipitation.
	// Accumulated precipitation
	SensorDeviceClassPrecipitation SensorDeviceClass = "precipitation"
	// SensorDeviceClassPrecipitationIntensity is a SensorDeviceClass of type precipitation_intensity.
	// Precipitation intensity
	SensorDeviceClassPrecipitationIntensity SensorDeviceClass = "precipitation_intensity"
	// SensorDeviceClassPressure is a SensorDeviceClass of type pressure.
	// Pressure.
	SensorDeviceClassPressure SensorDeviceClass = "pressure"
	// SensorDeviceClassReactivePower is a SensorDeviceClass of type reactive_power.
	// Reactive power
	SensorDeviceClassReactivePower SensorDeviceClass = "reactive_power"
	// SensorDeviceClassSignalStrength is a SensorDeviceClass of type signal_strength.
	// Signal strength
	SensorDeviceClassSignalStrength SensorDeviceClass = "signal_strength"
	// SensorDeviceClassSoundPressure is a SensorDeviceClass of type sound_pressure.
	// Sound pressure
	SensorDeviceClassSoundPressure SensorDeviceClass = "sound_pressure"
	// SensorDeviceClassSpeed is a SensorDeviceClass of type speed.
	// Generic speed
	SensorDeviceClassSpeed SensorDeviceClass = "speed"
	// SensorDeviceClassSulphurDioxide is a SensorDeviceClass of type sulphur_dioxide.
	// Concentration of sulphure dioxide
	SensorDeviceClassSulphurDioxide SensorDeviceClass = "sulphur_dioxide"
	// SensorDeviceClassTemperature is a SensorDeviceClass of type temperature.
	// Temperature.
	SensorDeviceClassTemperature SensorDeviceClass = "temperature"
	// SensorDeviceClassTimestamp is a SensorDeviceClass of type timestamp.
	// Timestamp. Requires native_value to return a Python datetime.datetime object, with time zone information, or None.
	SensorDeviceClassTimestamp SensorDeviceClass = "timestamp"
	// SensorDeviceClassVolatileOrganicCompounds is a SensorDeviceClass of type volatile_organic_compounds.
	// Concentration of volatile organic compounds
	SensorDeviceClassVolatileOrganicCompounds SensorDeviceClass = "volatile_organic_compounds"
	// SensorDeviceClassVolatileOrganicCompoundsParts is a SensorDeviceClass of type volatile_organic_compounds_parts.
	// Ratio of volatile organic compounds
	SensorDeviceClassVolatileOrganicCompoundsParts SensorDeviceClass = "volatile_organic_compounds_parts"
	// SensorDeviceClassVoltage is a SensorDeviceClass of type voltage.
	// Voltage
	SensorDeviceClassVoltage SensorDeviceClass = "voltage"
	// SensorDeviceClassVolume is a SensorDeviceClass of type volume.
	// Generic volume, this device class should be used for sensors representing a consumption, for example the amount of fuel consumed by a vehicle.
	SensorDeviceClassVolume SensorDeviceClass = "volume"
	// SensorDeviceClassVolumeFlowRate is a SensorDeviceClass of type volume_flow_rate.
	// Volume flow rate, this device class should be used for sensors representing a flow of some volume, for example the amount of water consumed momentarily.
	SensorDeviceClassVolumeFlowRate SensorDeviceClass = "volume_flow_rate"
	// SensorDeviceClassVolumeStorage is a SensorDeviceClass of type volume_storage.
	// Generic stored volume, this device class should be used for sensors representing a stored volume, for example the amount of fuel in a fuel tank.
	SensorDeviceClassVolumeStorage SensorDeviceClass = "volume_storage"
	// SensorDeviceClassWater is a SensorDeviceClass of type water.
	// Water consumption
	SensorDeviceClassWater SensorDeviceClass = "water"
	// SensorDeviceClassWeight is a SensorDeviceClass of type weight.
	// Generic mass; weight is used instead of mass to fit with every day language.
	SensorDeviceClassWeight SensorDeviceClass = "weight"
	// SensorDeviceClassWindDirection is a SensorDeviceClass of type wind_direction.
	// Wind direction
	SensorDeviceClassWindDirection SensorDeviceClass = "wind_direction"
	// SensorDeviceClassWindSpeed is a SensorDeviceClass of type wind_speed.
	// Wind speed
	SensorDeviceClassWindSpeed SensorDeviceClass = "wind_speed"
)

var ErrInvalidSensorDeviceClass = fmt.Errorf("not a valid SensorDeviceClass, try [%s]", strings.Join(_SensorDeviceClassNames, ", "))

var _SensorDeviceClassNames = []string{
	string(SensorDeviceClassApparentPower),
	string(SensorDeviceClassAqi),
	string(SensorDeviceClassArea),
	string(SensorDeviceClassAtmosphericPressure),
	string(SensorDeviceClassBattery),
	string(SensorDeviceClassBloodGlucoseConcentration),
	string(SensorDeviceClassCo2),
	string(SensorDeviceClassCo),
	string(SensorDeviceClassConductivity),
	string(SensorDeviceClassCurrent),
	string(SensorDeviceClassDataRate),
	string(SensorDeviceClassDataSize),
	string(SensorDeviceClassDate),
	string(SensorDeviceClassDistance),
	string(SensorDeviceClassDuration),
	string(SensorDeviceClassEnergy),
	string(SensorDeviceClassEnergyDistance),
	string(SensorDeviceClassEnergyStorage),
	string(SensorDeviceClassEnum),
	string(SensorDeviceClassFrequency),
	string(SensorDeviceClassGas),
	string(SensorDeviceClassHumidity),
	string(SensorDeviceClassIlluminance),
	string(SensorDeviceClassIrradiance),
	string(SensorDeviceClassMoisture),
	string(SensorDeviceClassMonetary),
	string(SensorDeviceClassNitrogenDioxide),
	string(SensorDeviceClassNitrogenMonoxide),
	string(SensorDeviceClassNitrousOxide),
	string(SensorDeviceClassOzone),
	string(SensorDeviceClassPh),
	string(SensorDeviceClassPm1),
	string(SensorDeviceClassPm25),
	string(SensorDeviceClassPm10),
	string(SensorDeviceClassPower),
	string(SensorDeviceClassPowerFactor),
	string(SensorDeviceClassPrecipitation),
	string(SensorDeviceClassPrecipitationIntensity),
	string(SensorDeviceClassPressure),
	string(SensorDeviceClassReactivePower),
	string(SensorDeviceClassSignalStrength),
	string(SensorDeviceClassSoundPressure),
	string(SensorDeviceClassSpeed),
	string(SensorDeviceClassSulphurDioxide),
	string(SensorDeviceClassTemperature),
	string(SensorDeviceClassTimestamp),
	string(SensorDeviceClassVolatileOrganicCompounds),
	string(SensorDeviceClassVolatileOrganicCompoundsParts),
	string(SensorDeviceClassVoltage),
	string(SensorDeviceClassVolume),
	string(SensorDeviceClassVolumeFlowRate),
	string(SensorDeviceClassVolumeStorage),
	string(SensorDeviceClassWater),
	string(SensorDeviceClassWeight),
	string(SensorDeviceClassWindDirection),
	string(SensorDeviceClassWindSpeed),
}

// SensorDeviceClassNames returns a list of possible string values of SensorDeviceClass.
func SensorDeviceClassNames() []string {
	tmp := make([]string, len(_SensorDeviceClassNames))
	copy(tmp, _SensorDeviceClassNames)
	return tmp
}

// SensorDeviceClassValues returns a list of the values for SensorDeviceClass
func SensorDeviceClassValues() []SensorDeviceClass {
	return []SensorDeviceClass{
		SensorDeviceClassApparentPower,
		SensorDeviceClassAqi,
		SensorDeviceClassArea,
		SensorDeviceClassAtmosphericPressure,
		SensorDeviceClassBattery,
		SensorDeviceClassBloodGlucoseConcentration,
		SensorDeviceClassCo2,
		SensorDeviceClassCo,
		SensorDeviceClassConductivity,
		SensorDeviceClassCurrent,
		SensorDeviceClassDataRate,
		SensorDeviceClassDataSize,
		SensorDeviceClassDate,
		SensorDeviceClassDistance,
		SensorDeviceClassDuration,
		SensorDeviceClassEnergy,
		SensorDeviceClassEnergyDistance,
		SensorDeviceClassEnergyStorage,
		SensorDeviceClassEnum,
		SensorDeviceClassFrequency,
		SensorDeviceClassGas,
		SensorDeviceClassHumidity,
		SensorDeviceClassIlluminance,
		SensorDeviceClassIrradiance,
		SensorDeviceClassMoisture,
		SensorDeviceClassMonetary,
		SensorDeviceClassNitrogenDioxide,
		SensorDeviceClassNitrogenMonoxide,
		SensorDeviceClassNitrousOxide,
		SensorDeviceClassOzone,
		SensorDeviceClassPh,
		SensorDeviceClassPm1,
		SensorDeviceClassPm25,
		SensorDeviceClassPm10,
		SensorDeviceClassPower,
		SensorDeviceClassPowerFactor,
		SensorDeviceClassPrecipitation,
		SensorDeviceClassPrecipitationIntensity,
		SensorDeviceClassPressure,
		SensorDeviceClassReactivePower,
		SensorDeviceClassSignalStrength,
		SensorDeviceClassSoundPressure,
		SensorDeviceClassSpeed,
		SensorDeviceClassSulphurDioxide,
		SensorDeviceClassTemperature,
		SensorDeviceClassTimestamp,
		SensorDeviceClassVolatileOrganicCompounds,
		SensorDeviceClassVolatileOrganicCompoundsParts,
		SensorDeviceClassVoltage,
		SensorDeviceClassVolume,
		SensorDeviceClassVolumeFlowRate,
		SensorDeviceClassVolumeStorage,
		SensorDeviceClassWater,
		SensorDeviceClassWeight,
		SensorDeviceClassWindDirection,
		SensorDeviceClassWindSpeed,
	}
}

// String implements the Stringer interface.
func (x SensorDeviceClass) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SensorDeviceClass) IsValid() bool {
	_, err := ParseSensorDeviceClass(string(x))
	return err == nil
}

var _SensorDeviceClassValue = map[string]SensorDeviceClass{
	"apparent_power":                   SensorDeviceClassApparentPower,
	"aqi":                              SensorDeviceClassAqi,
	"area":                             SensorDeviceClassArea,
	"atmospheric_pressure":             SensorDeviceClassAtmosphericPressure,
	"battery":                          SensorDeviceClassBattery,
	"blood_glucose_concentration":      SensorDeviceClassBloodGlucoseConcentration,
	"co2":                              SensorDeviceClassCo2,
	"co":                               SensorDeviceClassCo,
	"conductivity":                     SensorDeviceClassConductivity,
	"current":                          SensorDeviceClassCurrent,
	"data_rate":                        SensorDeviceClassDataRate,
	"data_size":                        SensorDeviceClassDataSize,
	"date":                             SensorDeviceClassDate,
	"distance":                         SensorDeviceClassDistance,
	"duration":                         SensorDeviceClassDuration,
	"energy":                           SensorDeviceClassEnergy,
	"energy_distance":                  SensorDeviceClassEnergyDistance,
	"energy_storage":                   SensorDeviceClassEnergyStorage,
	"enum":                             SensorDeviceClassEnum,
	"frequency":                        SensorDeviceClassFrequency,
	"gas":                              SensorDeviceClassGas,
	"humidity":                         SensorDeviceClassHumidity,
	"illuminance":                      SensorDeviceClassIlluminance,
	"irradiance":                       SensorDeviceClassIrradiance,
	"moisture":                         SensorDeviceClassMoisture,
	"monetary":                         SensorDeviceClassMonetary,
	"nitrogen_dioxide":                 SensorDeviceClassNitrogenDioxide,
	"nitrogen_monoxide":                SensorDeviceClassNitrogenMonoxide,
	"nitrous_oxide":                    SensorDeviceClassNitrousOxide,
	"ozone":                            SensorDeviceClassOzone,
	"ph":                               SensorDeviceClassPh,
	"pm1":                              SensorDeviceClassPm1,
	"pm25":                             SensorDeviceClassPm25,
	"pm10":                             SensorDeviceClassPm10,
	"power":                            SensorDeviceClassPower,
	"power_factor":                     SensorDeviceClassPowerFactor,
	"precipitation":                    SensorDeviceClassPrecipitation,
	"precipitation_intensity":          SensorDeviceClassPrecipitationIntensity,
	"pressure":                         SensorDeviceClassPressure,
	"reactive_power":                   SensorDeviceClassReactivePower,
	"signal_strength":                  SensorDeviceClassSignalStrength,
	"sound_pressure":                   SensorDeviceClassSoundPressure,
	"speed":                            SensorDeviceClassSpeed,
	"sulphur_dioxide":                  SensorDeviceClassSulphurDioxide,
	"temperature":                      SensorDeviceClassTemperature,
	"timestamp":                        SensorDeviceClassTimestamp,
	"volatile_organic_compounds":       SensorDeviceClassVolatileOrganicCompounds,
	"volatile_organic_compounds_parts": SensorDeviceClassVolatileOrganicCompoundsParts,
	"voltage":                          SensorDeviceClassVoltage,
	"volume":                           SensorDeviceClassVolume,
	"volume_flow_rate":                 SensorDeviceClassVolumeFlowRate,
	"volume_storage":                   SensorDeviceClassVolumeStorage,
	"water":                            SensorDeviceClassWater,
	"weight":                           SensorDeviceClassWeight,
	"wind_direction":                   SensorDeviceClassWindDirection,
	"wind_speed":                       SensorDeviceClassWindSpeed,
}

// ParseSensorDeviceClass attempts to convert a string to a SensorDeviceClass.
func ParseSensorDeviceClass(name string) (SensorDeviceClass, error) {
	if x, ok := _SensorDeviceClassValue[name]; ok {
		return x, nil
	}
	return SensorDeviceClass(""), fmt.Errorf("%s is %w", name, ErrInvalidSensorDeviceClass)
}

// MarshalText implements the text marshaller method.
func (x SensorDeviceClass) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SensorDeviceClass) UnmarshalText(text []byte) error {
	tmp, err := ParseSensorDeviceClass(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SensorLastResetTypeNone is a SensorLastResetType of type None.
	SensorLastResetTypeNone SensorLastResetType = iota
	// SensorLastResetTypeNever is a SensorLastResetType of type Never.
	SensorLastResetTypeNever
	// SensorLastResetTypeAuto is a SensorLastResetType of type Auto.
	SensorLastResetTypeAuto
)

var ErrInvalidSensorLastResetType = fmt.Errorf("not a valid SensorLastResetType, try [%s]", strings.Join(_SensorLastResetTypeNames, ", "))

const _SensorLastResetTypeName = "noneneverauto"

var _SensorLastResetTypeNames = []string{
	_SensorLastResetTypeName[0:4],
	_SensorLastResetTypeName[4:9],
	_SensorLastResetTypeName[9:13],
}

// SensorLastResetTypeNames returns a list of possible string values of SensorLastResetType.
func SensorLastResetTypeNames() []string {
	tmp := make([]string, len(_SensorLastResetTypeNames))
	copy(tmp, _SensorLastResetTypeNames)
	return tmp
}

// SensorLastResetTypeValues returns a list of the values for SensorLastResetType
func SensorLastResetTypeValues() []SensorLastResetType {
	return []SensorLastResetType{
		SensorLastResetTypeNone,
		SensorLastResetTypeNever,
		SensorLastResetTypeAuto,
	}
}

var _SensorLastResetTypeMap = map[SensorLastResetType]string{
	SensorLastResetTypeNone:  _SensorLastResetTypeName[0:4],
	SensorLastResetTypeNever: _SensorLastResetTypeName[4:9],
	SensorLastResetTypeAuto:  _SensorLastResetTypeName[9:13],
}

// String implements the Stringer interface.
func (x SensorLastResetType) String() string {
	if str, ok := _SensorLastResetTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SensorLastResetType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SensorLastResetType) IsValid() bool {
	_, ok := _SensorLastResetTypeMap[x]
	return ok
}

var _SensorLastResetTypeValue = map[string]SensorLastResetType{
	_SensorLastResetTypeName[0:4]:  SensorLastResetTypeNone,
	_SensorLastResetTypeName[4:9]:  SensorLastResetTypeNever,
	_SensorLastResetTypeName[9:13]: SensorLastResetTypeAuto,
}

// ParseSensorLastResetType attempts to convert a string to a SensorLastResetType.
func ParseSensorLastResetType(name string) (SensorLastResetType, error) {
	if x, ok := _SensorLastResetTypeValue[name]; ok {
		return x, nil
	}
	return SensorLastResetType(0), fmt.Errorf("%s is %w", name, ErrInvalidSensorLastResetType)
}

// MarshalText implements the text marshaller method.
func (x SensorLastResetType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SensorLastResetType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSensorLastResetType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SensorStateClassNone is a SensorStateClass of type None.
	SensorStateClassNone SensorStateClass = iota
	// SensorStateClassMeasurement is a SensorStateClass of type Measurement.
	// The state represents a measurement in present time, not a historical aggregation such as statistics or a prediction of the future. Examples of what should be classified measurement are: current temperature, humidity or electric power. Examples of what should not be classified as measurement: Forecasted temperature for tomorrow, yesterday's energy consumption or anything else that doesn't include the current measurement. For supported sensors, statistics of hourly min, max and average sensor readings is updated every 5 minutes.
	SensorStateClassMeasurement
	// SensorStateClassTotal is a SensorStateClass of type Total.
	// The state represents a total amount that can both increase and decrease, e.g. a net energy meter. Statistics of the accumulated growth or decline of the sensor's value since it was first added is updated every 5 minutes. This state class should not be used for sensors where the absolute value is interesting instead of the accumulated growth or decline, for example remaining battery capacity or CPU load; in such cases state class measurement should be used instead.
	SensorStateClassTotal
	// SensorStateClassTotalIncreasing is a SensorStateClass of type Total_increasing.
	// Similar to total, with the restriction that the state represents a monotonically increasing positive total which periodically restarts counting from 0, e.g. a daily amount of consumed gas, weekly water consumption or lifetime energy consumption. Statistics of the accumulated growth of the sensor's value since it was first added is updated every 5 minutes. A decreasing value is interpreted as the start of a new meter cycle or the replacement of the meter.
	SensorStateClassTotalIncreasing
)

var ErrInvalidSensorStateClass = fmt.Errorf("not a valid SensorStateClass, try [%s]", strings.Join(_SensorStateClassNames, ", "))

const _SensorStateClassName = "nonemeasurementtotaltotal_increasing"

var _SensorStateClassNames = []string{
	_SensorStateClassName[0:4],
	_SensorStateClassName[4:15],
	_SensorStateClassName[15:20],
	_SensorStateClassName[20:36],
}

// SensorStateClassNames returns a list of possible string values of SensorStateClass.
func SensorStateClassNames() []string {
	tmp := make([]string, len(_SensorStateClassNames))
	copy(tmp, _SensorStateClassNames)
	return tmp
}

// SensorStateClassValues returns a list of the values for SensorStateClass
func SensorStateClassValues() []SensorStateClass {
	return []SensorStateClass{
		SensorStateClassNone,
		SensorStateClassMeasurement,
		SensorStateClassTotal,
		SensorStateClassTotalIncreasing,
	}
}

var _SensorStateClassMap = map[SensorStateClass]string{
	SensorStateClassNone:            _SensorStateClassName[0:4],
	SensorStateClassMeasurement:     _SensorStateClassName[4:15],
	SensorStateClassTotal:           _SensorStateClassName[15:20],
	SensorStateClassTotalIncreasing: _SensorStateClassName[20:36],
}

// String implements the Stringer interface.
func (x SensorStateClass) String() string {
	if str, ok := _SensorStateClassMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SensorStateClass(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SensorStateClass) IsValid() bool {
	_, ok := _SensorStateClassMap[x]
	return ok
}

var _SensorStateClassValue = map[string]SensorStateClass{
	_SensorStateClassName[0:4]:   SensorStateClassNone,
	_SensorStateClassName[4:15]:  SensorStateClassMeasurement,
	_SensorStateClassName[15:20]: SensorStateClassTotal,
	_SensorStateClassName[20:36]: SensorStateClassTotalIncreasing,
}

// ParseSensorStateClass attempts to convert a string to a SensorStateClass.
func ParseSensorStateClass(name string) (SensorStateClass, error) {
	if x, ok := _SensorStateClassValue[name]; ok {
		return x, nil
	}
	return SensorStateClass(0), fmt.Errorf("%s is %w", name, ErrInvalidSensorStateClass)
}

// MarshalText implements the text marshaller method.
func (x SensorStateClass) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SensorStateClass) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSensorStateClass(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SwitchDeviceClassOutlet is a SwitchDeviceClass of type outlet.
	// Device is an outlet for power.
	SwitchDeviceClassOutlet SwitchDeviceClass = "outlet"
	// SwitchDeviceClassSwitch is a SwitchDeviceClass of type switch.
	// Device is switch for some type of entity.
	SwitchDeviceClassSwitch SwitchDeviceClass = "switch"
)

var ErrInvalidSwitchDeviceClass = fmt.Errorf("not a valid SwitchDeviceClass, try [%s]", strings.Join(_SwitchDeviceClassNames, ", "))

var _SwitchDeviceClassNames = []string{
	string(SwitchDeviceClassOutlet),
	string(SwitchDeviceClassSwitch),
}

// SwitchDeviceClassNames returns a list of possible string values of SwitchDeviceClass.
func SwitchDeviceClassNames() []string {
	tmp := make([]string, len(_SwitchDeviceClassNames))
	copy(tmp, _SwitchDeviceClassNames)
	return tmp
}

// SwitchDeviceClassValues returns a list of the values for SwitchDeviceClass
func SwitchDeviceClassValues() []SwitchDeviceClass {
	return []SwitchDeviceClass{
		SwitchDeviceClassOutlet,
		SwitchDeviceClassSwitch,
	}
}

// String implements the Stringer interface.
func (x SwitchDeviceClass) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SwitchDeviceClass) IsValid() bool {
	_, err := ParseSwitchDeviceClass(string(x))
	return err == nil
}

var _SwitchDeviceClassValue = map[string]SwitchDeviceClass{
	"outlet": SwitchDeviceClassOutlet,
	"switch": SwitchDeviceClassSwitch,
}

// ParseSwitchDeviceClass attempts to convert a string to a SwitchDeviceClass.
func ParseSwitchDeviceClass(name string) (SwitchDeviceClass, error) {
	if x, ok := _SwitchDeviceClassValue[name]; ok {
		return x, nil
	}
	return SwitchDeviceClass(""), fmt.Errorf("%s is %w", name, ErrInvalidSwitchDeviceClass)
}

// MarshalText implements the text marshaller method.
func (x SwitchDeviceClass) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SwitchDeviceClass) UnmarshalText(text []byte) error {
	tmp, err := ParseSwitchDeviceClass(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// TextModeText is a TextMode of type Text.
	TextModeText TextMode = iota
	// TextModePassword is a TextMode of type Password.
	TextModePassword
)

var ErrInvalidTextMode = fmt.Errorf("not a valid TextMode, try [%s]", strings.Join(_TextModeNames, ", "))

const _TextModeName = "textpassword"

var _TextModeNames = []string{
	_TextModeName[0:4],
	_TextModeName[4:12],
}

// TextModeNames returns a list of possible string values of TextMode.
func TextModeNames() []string {
	tmp := make([]string, len(_TextModeNames))
	copy(tmp, _TextModeNames)
	return tmp
}

// TextModeValues returns a list of the values for TextMode
func TextModeValues() []TextMode {
	return []TextMode{
		TextModeText,
		TextModePassword,
	}
}

var _TextModeMap = map[TextMode]string{
	TextModeText:     _TextModeName[0:4],
	TextModePassword: _TextModeName[4:12],
}

// String implements the Stringer interface.
func (x TextMode) String() string {
	if str, ok := _TextModeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TextMode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TextMode) IsValid() bool {
	_, ok := _TextModeMap[x]
	return ok
}

var _TextModeValue = map[string]TextMode{
	_TextModeName[0:4]:  TextModeText,
	_TextModeName[4:12]: TextModePassword,
}

// ParseTextMode attempts to convert a string to a TextMode.
func ParseTextMode(name string) (TextMode, error) {
	if x, ok := _TextModeValue[name]; ok {
		return x, nil
	}
	return TextMode(0), fmt.Errorf("%s is %w", name, ErrInvalidTextMode)
}

// MarshalText implements the text marshaller method.
func (x TextMode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TextMode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseTextMode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UpdateDeviceClassFirmware is a UpdateDeviceClass of type firmware.
	UpdateDeviceClassFirmware UpdateDeviceClass = "firmware"
)

var ErrInvalidUpdateDeviceClass = fmt.Errorf("not a valid UpdateDeviceClass, try [%s]", strings.Join(_UpdateDeviceClassNames, ", "))

var _UpdateDeviceClassNames = []string{
	string(UpdateDeviceClassFirmware),
}

// UpdateDeviceClassNames returns a list of possible string values of UpdateDeviceClass.
func UpdateDeviceClassNames() []string {
	tmp := make([]string, len(_UpdateDeviceClassNames))
	copy(tmp, _UpdateDeviceClassNames)
	return tmp
}

// UpdateDeviceClassValues returns a list of the values for UpdateDeviceClass
func UpdateDeviceClassValues() []UpdateDeviceClass {
	return []UpdateDeviceClass{
		UpdateDeviceClassFirmware,
	}
}

// String implements the Stringer interface.
func (x UpdateDeviceClass) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UpdateDeviceClass) IsValid() bool {
	_, err := ParseUpdateDeviceClass(string(x))
	return err == nil
}

var _UpdateDeviceClassValue = map[string]UpdateDeviceClass{
	"firmware": UpdateDeviceClassFirmware,
}

// ParseUpdateDeviceClass attempts to convert a string to a UpdateDeviceClass.
func ParseUpdateDeviceClass(name string) (UpdateDeviceClass, error) {
	if x, ok := _UpdateDeviceClassValue[name]; ok {
		return x, nil
	}
	return UpdateDeviceClass(""), fmt.Errorf("%s is %w", name, ErrInvalidUpdateDeviceClass)
}

// MarshalText implements the text marshaller method.
func (x UpdateDeviceClass) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *UpdateDeviceClass) UnmarshalText(text []byte) error {
	tmp, err := ParseUpdateDeviceClass(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ValveDeviceClassWater is a ValveDeviceClass of type water.
	// Control of a water valve.
	ValveDeviceClassWater ValveDeviceClass = "water"
	// ValveDeviceClassGas is a ValveDeviceClass of type gas.
	// Control of a gas valve.
	ValveDeviceClassGas ValveDeviceClass = "gas"
)

var ErrInvalidValveDeviceClass = fmt.Errorf("not a valid ValveDeviceClass, try [%s]", strings.Join(_ValveDeviceClassNames, ", "))

var _ValveDeviceClassNames = []string{
	string(ValveDeviceClassWater),
	string(ValveDeviceClassGas),
}

// ValveDeviceClassNames returns a list of possible string values of ValveDeviceClass.
func ValveDeviceClassNames() []string {
	tmp := make([]string, len(_ValveDeviceClassNames))
	copy(tmp, _ValveDeviceClassNames)
	return tmp
}

// ValveDeviceClassValues returns a list of the values for ValveDeviceClass
func ValveDeviceClassValues() []ValveDeviceClass {
	return []ValveDeviceClass{
		ValveDeviceClassWater,
		ValveDeviceClassGas,
	}
}

// String implements the Stringer interface.
func (x ValveDeviceClass) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ValveDeviceClass) IsValid() bool {
	_, err := ParseValveDeviceClass(string(x))
	return err == nil
}

var _ValveDeviceClassValue = map[string]ValveDeviceClass{
	"water": ValveDeviceClassWater,
	"gas":   ValveDeviceClassGas,
}

// ParseValveDeviceClass attempts to convert a string to a ValveDeviceClass.
func ParseValveDeviceClass(name string) (ValveDeviceClass, error) {
	if x, ok := _ValveDeviceClassValue[name]; ok {
		return x, nil
	}
	return ValveDeviceClass(""), fmt.Errorf("%s is %w", name, ErrInvalidValveDeviceClass)
}

// MarshalText implements the text marshaller method.
func (x ValveDeviceClass) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ValveDeviceClass) UnmarshalText(text []byte) error {
	tmp, err := ParseValveDeviceClass(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ValveOperationIdle is a ValveOperation of type Idle.
	ValveOperationIdle ValveOperation = iota
	// ValveOperationIsOpening is a ValveOperation of type Is_opening.
	ValveOperationIsOpening
	// ValveOperationIsClosing is a ValveOperation of type Is_closing.
	ValveOperationIsClosing
)

var ErrInvalidValveOperation = fmt.Errorf("not a valid ValveOperation, try [%s]", strings.Join(_ValveOperationNames, ", "))

const _ValveOperationName = "idleis_openingis_closing"

var _ValveOperationNames = []string{
	_ValveOperationName[0:4],
	_ValveOperationName[4:14],
	_ValveOperationName[14:24],
}

// ValveOperationNames returns a list of possible string values of ValveOperation.
func ValveOperationNames() []string {
	tmp := make([]string, len(_ValveOperationNames))
	copy(tmp, _ValveOperationNames)
	return tmp
}

// ValveOperationValues returns a list of the values for ValveOperation
func ValveOperationValues() []ValveOperation {
	return []ValveOperation{
		ValveOperationIdle,
		ValveOperationIsOpening,
		ValveOperationIsClosing,
	}
}

var _ValveOperationMap = map[ValveOperation]string{
	ValveOperationIdle:      _ValveOperationName[0:4],
	ValveOperationIsOpening: _ValveOperationName[4:14],
	ValveOperationIsClosing: _ValveOperationName[14:24],
}

// String implements the Stringer interface.
func (x ValveOperation) String() string {
	if str, ok := _ValveOperationMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ValveOperation(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ValveOperation) IsValid() bool {
	_, ok := _ValveOperationMap[x]
	return ok
}

var _ValveOperationValue = map[string]ValveOperation{
	_ValveOperationName[0:4]:   ValveOperationIdle,
	_ValveOperationName[4:14]:  ValveOperationIsOpening,
	_ValveOperationName[14:24]: ValveOperationIsClosing,
}

// ParseValveOperation attempts to convert a string to a ValveOperation.
func ParseValveOperation(name string) (ValveOperation, error) {
	if x, ok := _ValveOperationValue[name]; ok {
		return x, nil
	}
	return ValveOperation(0), fmt.Errorf("%s is %w", name, ErrInvalidValveOperation)
}

// MarshalText implements the text marshaller method.
func (x ValveOperation) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ValveOperation) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseValveOperation(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
