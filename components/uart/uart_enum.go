// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package uart

import (
	"errors"
	"fmt"
)

const (
	// ParityNo is a parity of type No.
	// disable parity control (default)
	ParityNo parity = iota
	// ParityOdd is a parity of type Odd.
	// enable odd-parity check
	ParityOdd
	// ParityEven is a parity of type Even.
	// enable even-parity check
	ParityEven
	// ParityMark is a parity of type Mark.
	// enable mark-parity (always 1) check
	ParityMark
	// ParitySpace is a parity of type Space.
	// enable space-parity (always 0) check
	ParitySpace
)

var ErrInvalidparity = errors.New("not a valid parity")

const _parityName = "nooddevenmarkspace"

var _parityMap = map[parity]string{
	ParityNo:    _parityName[0:2],
	ParityOdd:   _parityName[2:5],
	ParityEven:  _parityName[5:9],
	ParityMark:  _parityName[9:13],
	ParitySpace: _parityName[13:18],
}

// String implements the Stringer interface.
func (x parity) String() string {
	if str, ok := _parityMap[x]; ok {
		return str
	}
	return fmt.Sprintf("parity(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x parity) IsValid() bool {
	_, ok := _parityMap[x]
	return ok
}

var _parityValue = map[string]parity{
	_parityName[0:2]:   ParityNo,
	_parityName[2:5]:   ParityOdd,
	_parityName[5:9]:   ParityEven,
	_parityName[9:13]:  ParityMark,
	_parityName[13:18]: ParitySpace,
}

// Parseparity attempts to convert a string to a parity.
func Parseparity(name string) (parity, error) {
	if x, ok := _parityValue[name]; ok {
		return x, nil
	}
	return parity(0), fmt.Errorf("%s is %w", name, ErrInvalidparity)
}

const (
	// StopbitsOne is a stopbits of type One.
	// sets 1 stop bit (default)
	StopbitsOne stopbits = iota
	// StopbitsOnePointFive is a stopbits of type One_point_five.
	// sets 1.5 stop bits
	StopbitsOnePointFive
	// StopbitsTwo is a stopbits of type Two.
	// sets 2 stop bits
	StopbitsTwo
)

var ErrInvalidstopbits = errors.New("not a valid stopbits")

const _stopbitsName = "oneone_point_fivetwo"

var _stopbitsMap = map[stopbits]string{
	StopbitsOne:          _stopbitsName[0:3],
	StopbitsOnePointFive: _stopbitsName[3:17],
	StopbitsTwo:          _stopbitsName[17:20],
}

// String implements the Stringer interface.
func (x stopbits) String() string {
	if str, ok := _stopbitsMap[x]; ok {
		return str
	}
	return fmt.Sprintf("stopbits(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x stopbits) IsValid() bool {
	_, ok := _stopbitsMap[x]
	return ok
}

var _stopbitsValue = map[string]stopbits{
	_stopbitsName[0:3]:   StopbitsOne,
	_stopbitsName[3:17]:  StopbitsOnePointFive,
	_stopbitsName[17:20]: StopbitsTwo,
}

// Parsestopbits attempts to convert a string to a stopbits.
func Parsestopbits(name string) (stopbits, error) {
	if x, ok := _stopbitsValue[name]; ok {
		return x, nil
	}
	return stopbits(0), fmt.Errorf("%s is %w", name, ErrInvalidstopbits)
}
